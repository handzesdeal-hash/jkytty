<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="0" />
<link rel="icon" type="image/png" href="./assets/hz-logo.png" />
<link rel="shortcut icon" href="./assets/hz-logo.png" />
<link rel="apple-touch-icon" href="./assets/hz-logo.png" />
<title>HANDZES.BET</title>
<meta name="theme-color" content="#07040f"/>
<style>
:root{
  --bg:#050508; --bg2:#070614;
  --text:rgba(255,255,255,.92); --muted:rgba(255,255,255,.62);
  --stroke:rgba(255,255,255,.10);
  --purple:#7c3aed; --purple2:#a78bfa; --red:#ef4444; --green:#22c55e; --amber:#f59e0b;
  --shadow:0 18px 60px rgba(0,0,0,.62);
  --shadow2:0 10px 40px rgba(0,0,0,.55);
  --mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
  --sans:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;color:var(--text);font-family:var(--sans);
  background:
    radial-gradient(1200px 900px at 18% 12%, rgba(124,58,237,.22), transparent 60%),
    radial-gradient(1200px 900px at 82% 12%, rgba(239,68,68,.14), transparent 60%),
    linear-gradient(180deg, var(--bg), var(--bg2));
  overflow-x:hidden;
}
.glow{filter: drop-shadow(0 0 10px rgba(167,139,250,.35)) drop-shadow(0 0 22px rgba(124,58,237,.18));}
.iconSvg{width:26px;height:26px;vertical-align:-3px;margin-left:0}
.iconPoop{width:22px;height:22px;vertical-align:-5px;margin-left:6px;filter: drop-shadow(0 0 10px rgba(0,0,0,.6));}

@keyframes shake { 0%,100%{transform:translateX(0)} 20%{transform:translateX(-4px)} 40%{transform:translateX(4px)} 60%{transform:translateX(-3px)} 80%{transform:translateX(3px)} }
@keyframes pop { 0%{transform:scale(.92)} 60%{transform:scale(1.08)} 100%{transform:scale(1)} }
@keyframes sparkle { 0%{filter:brightness(1)} 50%{filter:brightness(1.6)} 100%{filter:brightness(1)} }
.bombHit{animation: shake .35s ease-in-out}
.gemHit{animation: pop .18s ease-out, sparkle .55s ease-in-out}

.authWrap{min-height:100vh;display:none;align-items:center;justify-content:center;padding:22px;}
.authWrap.show{display:flex;}
.authCard{
  width:min(520px,100%);border-radius:22px;border:1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.32);box-shadow: var(--shadow);backdrop-filter: blur(14px);overflow:hidden;
}
.authTop{padding:16px;border-bottom:1px solid rgba(255,255,255,.10);display:flex;align-items:center;gap:12px;}
.mark{width:44px;height:44px;border-radius:16px;background:linear-gradient(135deg, rgba(124,58,237,.95), rgba(239,68,68,.88));border:1px solid rgba(255,255,255,.18);box-shadow:0 10px 28px rgba(0,0,0,.55);
  background-image:url('./assets/hz-logo.png'),linear-gradient(135deg, rgba(124,58,237,.95), rgba(239,68,68,.88));background-size:cover;background-position:center;background-repeat:no-repeat;}
.authTop b{letter-spacing:.22em;font-size:15px;}
.authBody{padding:16px;}
.tabs{display:flex;gap:10px;margin-bottom:12px;}
.tab{flex:1;padding:10px 12px;border-radius:14px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:rgba(255,255,255,.86);font-weight:950;cursor:pointer}
.tab.active{background:rgba(124,58,237,.20);border-color:rgba(167,139,250,.22)}
label{font-size:12px;color:var(--muted);font-weight:900;}
input,select{
  width:100%;margin-top:6px;padding:11px 12px;border-radius:14px;border:1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.22);color: rgba(255,255,255,.92);outline:none;font-size:13px;
}
input:focus,select:focus{border-color: rgba(167,139,250,.38);box-shadow:0 0 0 4px rgba(124,58,237,.16)}
.row{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px;}
.btn{
  border:1px solid rgba(255,255,255,.12);background: rgba(255,255,255,.06);color: rgba(255,255,255,.92);
  padding:11px 12px;border-radius:14px;font-weight:950;font-size:13px;cursor:pointer;user-select:none;
}
.btn:hover{background: rgba(255,255,255,.09)}
.btn:active{transform: translateY(1px)}
.btn.purple{background: linear-gradient(135deg, rgba(124,58,237,.95), rgba(167,139,250,.72));border-color:rgba(255,255,255,.16)}
.btn.red{background: linear-gradient(135deg, rgba(239,68,68,.95), rgba(251,113,133,.82));border-color:rgba(255,255,255,.16)}
.btn.green{background: linear-gradient(135deg, rgba(34,197,94,.95), rgba(134,239,172,.78));border-color:rgba(255,255,255,.16)}
.btn:disabled{opacity:.55;cursor:not-allowed}
.small{font-size:12px;color:var(--muted);line-height:1.35;margin-top:10px}

/* =======================
   MINES UPGRADE (right ladder)
   ======================= */

.minesWrap{
  margin-top:14px;
  display:grid;
  grid-template-columns: 520px 1fr;
  gap:14px;
  align-items:start;
}
@media(max-width:980px){
  .minesWrap{ grid-template-columns: 1fr; }
}

#minesGrid{
  display:grid;
  grid-template-columns:repeat(5,1fr);
  gap:10px;
  max-width:520px;
}

.minesRight{
  position:relative;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.28);
  border-radius:18px;
  padding:12px;
  overflow:hidden;
  min-height: 380px;
  box-shadow:0 16px 50px rgba(0,0,0,.45);
}
.minesRight::before{
  content:"";
  position:absolute;
  inset:-40%;
  background:
    radial-gradient(closest-side at 30% 30%, rgba(124,58,237,.22), transparent 60%),
    radial-gradient(closest-side at 70% 20%, rgba(239,68,68,.14), transparent 60%),
    conic-gradient(from 180deg, rgba(167,139,250,.12), transparent, rgba(239,68,68,.10), transparent);
  filter: blur(2px);
  pointer-events:none;
}

.minesRightHd{ position:relative; display:flex; justify-content:space-between; align-items:flex-end; gap:10px; }
.minesRightTitle{
  font-weight:1000;
  letter-spacing:.18em;
  font-size:12px;
  color: rgba(255,255,255,.92);
  text-transform:uppercase;
}
.minesRightSub{
  font-size:12px;
  color: rgba(255,255,255,.60);
  font-weight:900;
}

.minesLadder{
  position:relative;
  margin-top:10px;
  display:flex;
  flex-direction:column-reverse;
  gap:8px;
  max-height: 300px;
  overflow:auto;
  padding-right:6px;
}
.minesLadder::-webkit-scrollbar{ width:8px; }
.minesLadder::-webkit-scrollbar-thumb{ background: rgba(255,255,255,.12); border-radius:999px; }

.minesStep{
  position:relative;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.32);
  backdrop-filter: blur(10px);
}
.minesStep .left{
  display:flex; align-items:center; gap:10px;
  min-width:0;
}
.minesStep .pickNo{
  width:30px; height:30px; border-radius:12px;
  display:flex; align-items:center; justify-content:center;
  font-weight:1000;
  font-size:12px;
  color: rgba(255,255,255,.72);
  border:1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.04);
}
.minesStep .mx{
  font-family: var(--sans);
  font-weight:1000;
  letter-spacing:.02em;
  font-size:15px;
  color: rgba(255,255,255,.96);
  white-space:nowrap;
}
.minesStep .sub{
  font-size:11px;
  color: rgba(255,255,255,.55);
  font-weight:900;
  white-space:nowrap;
}

.minesStep.active{
  border-color: rgba(255,255,255,.22);
  background: rgba(255,255,255,.06);
  box-shadow: 0 0 0 4px rgba(255,255,255,.06), 0 18px 55px rgba(0,0,0,.55);
}
.minesStep.active .pickNo{
  color: rgba(255,255,255,.92);
  border-color: rgba(255,255,255,.18);
  background: rgba(255,255,255,.08);
}

@keyframes xJump{
  0%{ transform: translateY(8px) scale(.96); opacity:.0; }
  40%{ opacity:1; }
  100%{ transform: translateY(0) scale(1); opacity:1; }
}
.minesXFloat{
  position:absolute;
  right:14px;
  top:14px;
  padding:10px 12px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.14);
  background: rgba(0,0,0,.55);
  backdrop-filter: blur(12px);
  font-weight:1000;
  font-size:14px;
  color: rgba(255,255,255,.96);
  animation: xJump .22s ease-out;
  box-shadow:0 18px 55px rgba(0,0,0,.55);
  z-index:2;
}
.minesXFloat.bump{ animation: xJump .22s ease-out; }

/* =======================
   MINES CENTER POPUP — CLEAN & BALANCED
   ======================= */

.minesCenterPop{
  position:absolute;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%) scale(.92);
  width:min(280px, 80%);
  padding:14px;
  border-radius:22px;

  /* cleaner glass, less tint */
  background:
    radial-gradient(120% 120% at 30% 20%, rgba(255,255,255,.14), transparent 55%),
    rgba(12,12,18,.78);

  /* ✅ black outline + inner edge */
  border:1px solid rgba(0,0,0,.85);
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,.10),
    0 26px 90px rgba(0,0,0,.75),
    0 0 28px rgba(34,197,94,.18);

  backdrop-filter: blur(14px);
  -webkit-backdrop-filter: blur(14px);

  display:none;
  z-index:50;
  text-align:center;
  pointer-events:none;
}

/* softer glow ring */
.minesCenterPop::before{
  content:"";
  position:absolute;
  inset:-2px;
  border-radius:24px;
  background:
    linear-gradient(135deg,
      rgba(34,197,94,.0),
      rgba(34,197,94,.55),
      rgba(34,197,94,.0)
    );
  filter: blur(10px);
  opacity:.45;
  z-index:0;
}

/* inner panel */
.minesCenterPop .inner{
  position:relative;
  z-index:1;
  border-radius:16px;
  background: rgba(255,255,255,.05);
  border:1px solid rgba(255,255,255,.14);
  padding:14px 14px 12px;
}

/* label */
.minesCenterPop .label{
  font-size:11px;
  font-weight:900;
  letter-spacing:.18em;
  text-transform:uppercase;
  color: rgba(255,255,255,.70);
  margin-bottom:8px;
}

/* ✅ payout still dominant but smaller */
.minesCenterPop .amt{
  font-family: var(--mono);
  font-weight:1000;
  font-size:34px;
  line-height:1.05;
  color: rgba(255,255,255,.96);
  text-shadow: 0 0 16px rgba(34,197,94,.22);
}

/* multiplier secondary */
.minesCenterPop .mx{
  margin-top:8px;
  font-family: var(--mono);
  font-weight:900;
  font-size:16px;
  color: rgba(34,197,94,.95);
}

/* footer */
.minesCenterPop .sub{
  margin-top:10px;
  font-size:12px;
  font-weight:800;
  color: rgba(255,255,255,.65);
  display:flex;
  align-items:center;
  justify-content:center;
  gap:8px;
}

.minesCenterPop .dot{
  width:8px;
  height:8px;
  border-radius:999px;
  background: rgba(34,197,94,.95);
  box-shadow: 0 0 10px rgba(34,197,94,.45);
}

/* pop animation (calmer) */
@keyframes minesPopIn {
  0%   { opacity:0; transform:translate(-50%,-50%) scale(.86); }
  60%  { opacity:1; transform:translate(-50%,-50%) scale(1.03); }
  100% { opacity:1; transform:translate(-50%,-50%) scale(1); }
}
@keyframes minesPopOut {
  to { opacity:0; transform:translate(-50%,-50%) scale(.96); }
}

.minesCenterPop.show{
  display:block;
  animation: minesPopIn .22s ease-out;
}
.minesCenterPop.hide{
  animation: minesPopOut .18s ease-in forwards;
}

/* lose variant */
.minesCenterPop.lose{
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,.08),
    0 26px 90px rgba(0,0,0,.75),
    0 0 28px rgba(239,68,68,.18);
}
.minesCenterPop.lose::before{
  background:
    linear-gradient(135deg,
      rgba(239,68,68,.0),
      rgba(239,68,68,.55),
      rgba(239,68,68,.0)
    );
}
.minesCenterPop.lose .mx{
  color: rgba(239,68,68,.95);
}
.minesCenterPop.lose .dot{
  background: rgba(239,68,68,.95);
  box-shadow: 0 0 10px rgba(239,68,68,.45);
}

/* =======================
   MINES TILE ICON SIZES
   ======================= */
.minesGemSvg{
  width:34px;
  height:34px;
  filter: drop-shadow(0 0 10px rgba(253,230,138,.35)) drop-shadow(0 0 20px rgba(34,197,94,.12));
}

.minesBombSvg{
  width:34px;
  height:34px;
  filter: drop-shadow(0 0 10px rgba(239,68,68,.45)) drop-shadow(0 0 26px rgba(239,68,68,.20));
}

/* Bomb tile look */
.minesBombTile{
  background: rgba(239,68,68,.14) !important;
  border-color: rgba(239,68,68,.28) !important;
  box-shadow:
    inset 0 0 0 1px rgba(0,0,0,.55),
    0 0 0 4px rgba(239,68,68,.06),
    0 0 24px rgba(239,68,68,.18) !important;
}

/* =======================
   BOMB ICON + EXPLOSION (anchored to tile)
   ======================= */
.bombIcon{
  font-size:30px;line-height:1;display:inline-flex;align-items:center;justify-content:center;
  filter: drop-shadow(0 0 10px rgba(239,68,68,.65)) drop-shadow(0 0 22px rgba(239,68,68,.35));
  animation: bombPulse 0.85s ease-in-out infinite;
}

@keyframes bombPulse{
  0%,100%{ transform: scale(1); filter: drop-shadow(0 0 10px rgba(239,68,68,.55)) drop-shadow(0 0 22px rgba(239,68,68,.30)); }
  50%{ transform: scale(1.06); filter: drop-shadow(0 0 14px rgba(239,68,68,.75)) drop-shadow(0 0 28px rgba(239,68,68,.45)); }
}

/* explosion container anchored to tile */
.boom{
  position:absolute;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  width:10px;
  height:10px;
  pointer-events:none;
  z-index:10;
}

/* big shockwave ring */
.boom::before{
  content:"";
  position:absolute;
  inset:-52px;
  border-radius:999px;
  background:
    radial-gradient(circle,
      rgba(255,255,255,.30) 0%,
      rgba(239,68,68,.42) 18%,
      rgba(239,68,68,.18) 38%,
      rgba(239,68,68,0) 72%);
  filter: blur(1px);
  animation: boomRing .34s ease-out forwards;
}

@keyframes boomRing{
  0%{ transform:scale(.18); opacity:0; }
  18%{ opacity:1; }
  100%{ transform:scale(1.25); opacity:0; }
}

/* hot core flash */
.boom::after{
  content:"";
  position:absolute;
  inset:-20px;
  border-radius:999px;
  background: radial-gradient(circle, rgba(255,255,255,.55), rgba(239,68,68,.22), rgba(239,68,68,0) 70%);
  animation: boomFlash .22s ease-out forwards;
}
@keyframes boomFlash{
  0%{ transform:scale(.55); opacity:0; }
  30%{ opacity:1; }
  100%{ transform:scale(1.2); opacity:0; }
}

/* sparks */
.spark{
  position:absolute;
  left:50%;
  top:50%;
  width:4px;
  height:16px;
  border-radius:999px;
  transform-origin:50% 100%;
  background: linear-gradient(180deg, rgba(255,255,255,.95), rgba(255,180,180,.92), rgba(239,68,68,.95), rgba(239,68,68,0));
  filter: drop-shadow(0 0 12px rgba(239,68,68,.55)) drop-shadow(0 0 22px rgba(239,68,68,.25));
  animation: sparkFly .52s ease-out forwards;
}

@keyframes sparkFly{
  0%{ transform: translate(-50%,-50%) rotate(var(--a)) translateY(0) scale(1); opacity:1; }
  100%{ transform: translate(-50%,-50%) rotate(var(--a)) translateY(-74px) scale(.55); opacity:0; }
}

@keyframes sparkDot {
  0%   { transform: translate(0,0) scale(.8); opacity: 0; }
  15%  { opacity: 1; }
  100% { transform: translate(var(--dx), var(--dy)) scale(.1); opacity: 0; }
}
.sparkDot{
  position:absolute;
  left:50%;
  top:50%;
  width:5px;
  height:5px;
  border-radius:999px;
  transform: translate(-50%,-50%);
  background: radial-gradient(circle, rgba(255,255,255,.95) 0%, rgba(239,68,68,.9) 55%, rgba(239,68,68,0) 80%);
  filter: blur(.2px);
  pointer-events:none;
  z-index:6;
  animation: sparkDot .6s ease-out forwards;
}

/* ===== Mines win popup state management ===== */
.minesWinOverlay{
  position:absolute;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  z-index:30;
  pointer-events:none;
}
.minesWinOverlay.show{
  display:flex;
  pointer-events:auto;
}

.app{display:none;grid-template-columns:280px 1fr;min-height:100vh;}
.app.show{display:grid;}
@media(max-width:980px){.app{grid-template-columns:1fr}.sidebar{position:sticky;top:0;z-index:50;height:auto}.main{padding-top:10px}}
.mobileNav{display:none;position:sticky;top:10px;z-index:60;margin-bottom:12px;}
.mobileNavInner{display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:10px;border:1px solid rgba(255,255,255,.10);background:rgba(0,0,0,.32);border-radius:16px;padding:12px;box-shadow:0 12px 38px rgba(0,0,0,.35);}
.mobileNav .navBtn{padding:12px 14px;font-size:14px;background:rgba(255,255,255,.05);border:1px solid transparent;}
.mobileNav .navBtn.active{background:rgba(124,58,237,.18);border-color:rgba(167,139,250,.22)}
@media(max-width:900px){
  .sidebar{display:none;}
  .app{grid-template-columns:1fr;}
  .mobileNav{display:block;}
  .main{padding-top:12px;}
}
.sidebar{
  height:100vh;overflow:auto;padding:14px 12px 16px;border-right:1px solid rgba(255,255,255,.08);
  background: rgba(0,0,0,.30);backdrop-filter: blur(14px);
}
.brand{display:flex;align-items:center;gap:10px;padding:10px 10px 12px;border-radius:16px;border:1px solid rgba(255,255,255,.10);
  background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));box-shadow: var(--shadow2)}
.logo{width:40px;height:40px;border-radius:14px;background:linear-gradient(135deg, rgba(124,58,237,.95), rgba(239,68,68,.88));
  border:1px solid rgba(255,255,255,.18);box-shadow:0 10px 28px rgba(0,0,0,.55)}
.logo{background-image:url('./assets/hz-logo.png'),linear-gradient(135deg, rgba(124,58,237,.95), rgba(239,68,68,.88));background-size:cover;background-position:center;background-repeat:no-repeat;}
.brand b{letter-spacing:.22em;font-weight:1000;}
.brand small{display:block;color:var(--muted);margin-top:2px;font-size:12px;}
.sideTitle{margin-top:12px;padding:10px 10px 6px;color: rgba(255,255,255,.50);font-size:11px;font-weight:950;letter-spacing:.18em;text-transform:uppercase;}
.navBtn{
  width:100%;display:flex;align-items:center;justify-content:space-between;gap:10px;padding:11px 12px;border-radius:16px;border:1px solid transparent;
  background:transparent;color: rgba(255,255,255,.86);cursor:pointer;font-weight:950;font-size:13px;user-select:none;
}
.navBtn:hover{background: rgba(255,255,255,.06)}
.navBtn.active{background: rgba(124,58,237,.18);border-color: rgba(167,139,250,.22)}
.chip{font-family:var(--mono);font-size:11px;padding:4px 9px;border-radius:999px;border:1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.18);color: rgba(255,255,255,.78);white-space:nowrap;}
.chip.ok{border-color: rgba(34,197,94,.22);background: rgba(34,197,94,.10);}
.sideCard{margin-top:10px;border:1px solid rgba(255,255,255,.10);background: rgba(0,0,0,.22);border-radius:18px;padding:12px;box-shadow:0 16px 50px rgba(0,0,0,.45);}
.pill{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:9px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.18);color: rgba(255,255,255,.72);font-size:12px;margin-top:8px;}
.pill:first-child{margin-top:0}
.mono{font-family:var(--mono)}
.muted{color:var(--muted)}
.main{padding:14px 16px 42px;overflow:auto;}
.topbar{
  display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
  border:1px solid rgba(255,255,255,.10);background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
  border-radius:18px;padding:12px;box-shadow: var(--shadow);position:sticky;top:10px;z-index:40;
  /* remove heavy blur (causes moving seam/artifact). keep a subtle solid bg */
  backdrop-filter: none;
  -webkit-backdrop-filter: none;
  background: rgba(0,0,0,.45);
}
.centerBrand{display:flex;align-items:center;gap:14px;margin:0 auto;opacity:.98;}
.mark2{width:77px;height:77px;border-radius:16px;background:linear-gradient(135deg, rgba(124,58,237,.95), rgba(239,68,68,.85));border:1px solid rgba(255,255,255,.18);
  background-image:url('./assets/hz-logo.png'),linear-gradient(135deg, rgba(124,58,237,.95), rgba(239,68,68,.85));background-size:cover;background-position:center;background-repeat:no-repeat;}
.title{font-weight:1000;letter-spacing:.30em;font-size:18px;}
.walletMid{display:flex;align-items:center;gap:10px;padding:10px 12px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background: rgba(0,0,0,.22);font-weight:950;font-size:12.5px;}
.dot{width:8px;height:8px;border-radius:999px;background:var(--purple2);box-shadow:0 0 0 4px rgba(167,139,250,.14);}
.profileBtn{display:flex;align-items:center;gap:10px;padding:10px 12px;border-radius:14px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.20);cursor:pointer;user-select:none;}
.avatar{width:26px;height:26px;border-radius:10px;background:radial-gradient(16px 16px at 30% 30%, rgba(167,139,250,.95), rgba(124,58,237,.55));border:1px solid rgba(255,255,255,.16);}
.levelWrap{margin-top:6px;width:170px}
.levelBar{height:8px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.28);overflow:hidden}
.levelFill{height:100%;width:0%;background:linear-gradient(90deg, rgba(124,58,237,.9), rgba(167,139,250,.75));box-shadow:0 0 18px rgba(124,58,237,.25);}
.levelText{font-size:11px;color:var(--muted);margin-top:4px;display:flex;justify-content:space-between}

.section{margin-top:12px;border:1px solid rgba(255,255,255,.10);background: rgba(0,0,0,.16);border-radius:18px;overflow:hidden;box-shadow:0 14px 55px rgba(0,0,0,.45);}
.sectionHd{padding:14px;border-bottom:1px solid rgba(255,255,255,.07);display:flex;align-items:flex-start;justify-content:space-between;gap:10px;flex-wrap:wrap;}
.sectionHd h3{margin:0;font-size:14px;}
.sub{color:var(--muted);font-size:12px;margin-top:4px;line-height:1.35;}
.sectionBd{padding:14px;}
.grid{display:grid;grid-template-columns:repeat(6,1fr);gap:12px;}
@media(max-width:1300px){.grid{grid-template-columns:repeat(4,1fr);}}
@media(max-width:980px){.grid{grid-template-columns:repeat(2,1fr);}}
@media(max-width:520px){.grid{grid-template-columns:1fr;}}
.row{gap:12px;}
@media(max-width:640px){
  .main{padding:12px;}
  .topbar{position:static;border-radius:14px;padding:10px;gap:8px;}
  .centerBrand{flex-direction:column;gap:6px;}
  .centerBrand .title{font-size:16px;letter-spacing:.22em;}
  .walletMid{padding:9px 10px;font-size:12px;}
  .section{margin-top:14px;border-radius:16px;}
  .sectionHd{padding:12px;gap:8px;}
  .sectionHd h3{font-size:14px;}
  .sectionBd{padding:12px;}
  .grid{grid-template-columns:1fr;gap:14px;}
  input, select, button.btn{font-size:14px;}
  .miniPill{font-size:12.5px;}
  .row > [style*="width:220px"], .row > [style*="width:180px"]{width:100%!important;}
}
.tile{border:1px solid rgba(255,255,255,.10);background: rgba(0,0,0,.35);border-radius:18px;overflow:hidden;cursor:pointer;user-select:none;
  transition: transform .08s ease, border-color .15s ease, background .15s ease;box-shadow:0 18px 55px rgba(0,0,0,.50);}
.tile:hover{transform: translateY(-1px);border-color: rgba(255,255,255,.18);background: rgba(0,0,0,.44);}
.tileArt{height:120px;border-bottom:1px solid rgba(255,255,255,.08);display:flex;align-items:center;justify-content:center;position:relative;overflow:hidden}
.tileArt::before{content:"";position:absolute;inset:-40%;
  background:
    radial-gradient(closest-side at 30% 30%, rgba(124,58,237,.55), transparent 60%),
    radial-gradient(closest-side at 70% 30%, rgba(239,68,68,.28), transparent 60%),
    conic-gradient(from 180deg, rgba(167,139,250,.24), transparent, rgba(239,68,68,.20), transparent);
  filter: blur(2px);
}
.tileArt span{position:relative;font-size:34px}
.tileBody{padding:12px;}
.tileTitle{font-weight:950;font-size:13px;margin:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
.tileDesc{color:var(--muted);font-size:11.5px;margin-top:6px;line-height:1.35;height:32px;overflow:hidden;}
.tileMeta{margin-top:10px;display:flex;align-items:center;justify-content:space-between;gap:10px;}
.tag{display:inline-flex;align-items:center;padding:5px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background: rgba(255,255,255,.05);font-size:11.5px;font-weight:950;white-space:nowrap;}
.tag.open{background: rgba(34,197,94,.10);border-color: rgba(34,197,94,.18);}
.tag.closed{background: rgba(245,158,11,.10);border-color: rgba(245,158,11,.18);}
.tag.settled{background: rgba(239,68,68,.10);border-color: rgba(239,68,68,.18);}
.tag.pending{background: rgba(124,58,237,.12);border-color: rgba(167,139,250,.22);}
.oddsMini{font-family:var(--mono);font-size:11px;color: rgba(255,255,255,.72);}

table{width:100%;border-collapse:collapse;border-radius:16px;border:1px solid rgba(255,255,255,.10);background: rgba(0,0,0,.24);overflow:hidden;}
th,td{padding:9px;border-bottom:1px solid rgba(255,255,255,.08);font-size:12.5px;}
th{color:var(--muted);font-weight:950;letter-spacing:.2px;}
tr:last-child td{border-bottom:none;}
#view-leaderboard .sectionBd{padding:16px 18px;display:block;}
#view-leaderboard .lbWrap{width:100%;max-width:940px;}
#view-leaderboard .lbCard{border:1px solid rgba(255,255,255,.10);background: rgba(0,0,0,.22);border-radius:16px;box-shadow:0 12px 40px rgba(0,0,0,.42);overflow:hidden;}
#view-leaderboard .lbCardHd{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:12px 14px 10px;border-bottom:1px solid rgba(255,255,255,.08);}
#view-leaderboard .lbLabel{font-weight:950;letter-spacing:.14em;font-size:11px;text-transform:uppercase;color:rgba(255,255,255,.78);}
#view-leaderboard .lbSub{color:var(--muted);font-size:11.5px;margin-top:2px;}
#view-leaderboard .lbTable{max-width:100%;margin:0;border:1px solid rgba(255,255,255,.06);}
#view-leaderboard .lbTable th,#view-leaderboard .lbTable td{border-bottom:1px solid rgba(255,255,255,.05);}
#view-leaderboard .lbTable tr:last-child td{border-bottom:none;}
#view-leaderboard .lbRank{display:flex;align-items:center;justify-content:center;gap:6px;font-weight:900;width:100%;}
#view-leaderboard .lbRank .medal{display:inline-flex;align-items:center;justify-content:center;width:20px;height:20px;border-radius:999px;font-weight:1000;font-size:11px;line-height:1;color:#0f0f12;text-shadow:0 1px 0 rgba(0,0,0,.35);box-shadow:0 0 14px rgba(255,255,255,.14),0 0 8px rgba(0,0,0,.35);}
#view-leaderboard .lbRank .m1{background:linear-gradient(135deg,#ffe58f,#f7c948);box-shadow:0 0 16px rgba(255,215,97,.30),0 0 8px rgba(0,0,0,.35);}
#view-leaderboard .lbRank .m2{background:linear-gradient(135deg,#dfe7ff,#9fb6ff);box-shadow:0 0 14px rgba(160,185,255,.30),0 0 8px rgba(0,0,0,.35);}
#view-leaderboard .lbRank .m3{background:linear-gradient(135deg,#ffd5b0,#ff9f6f);box-shadow:0 0 14px rgba(255,175,120,.28),0 0 8px rgba(0,0,0,.35);}
#view-leaderboard th,#view-leaderboard td{padding:11px 12px;}
#view-leaderboard th:nth-child(1), #view-leaderboard td:nth-child(1){width:56px;text-align:center;}
#view-leaderboard th:nth-child(2), #view-leaderboard td:nth-child(2){text-align:left;}
#view-leaderboard th:nth-child(3), #view-leaderboard td:nth-child(3){text-align:right;}
#view-leaderboard th:nth-child(4), #view-leaderboard td:nth-child(4){text-align:right;}

.overlay{position:fixed;inset:0;background: rgba(0,0,0,.62);backdrop-filter: blur(10px);display:none;z-index:999;align-items:center;justify-content:center;padding:18px;}
.overlay.show{display:flex;}
.modal{width:min(920px,100%);border-radius:20px;border:1px solid rgba(255,255,255,.12);background: rgba(5,5,8,.92);box-shadow:0 26px 90px rgba(0,0,0,.75);overflow:hidden;}
.modalHd{padding:14px;border-bottom:1px solid rgba(255,255,255,.08);display:flex;align-items:flex-start;justify-content:space-between;gap:12px;flex-wrap:wrap;}
.modalHd h4{margin:0;font-size:16px;}
.modalHd p{margin:6px 0 0;color:var(--muted);font-size:12px;line-height:1.35;max-width:70ch;}
.closeBtn{border:1px solid rgba(255,255,255,.14);background: rgba(255,255,255,.06);color:rgba(255,255,255,.90);width:40px;height:40px;border-radius:14px;cursor:pointer;font-weight:950;}
.closeBtn:hover{background: rgba(255,255,255,.10);}
.modalBd{padding:14px;}
.oddsGrid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-top:10px;}
@media(max-width:760px){.oddsGrid{grid-template-columns:1fr;}}
.oddBtn{border:1px solid rgba(255,255,255,.12);background: rgba(0,0,0,.50);border-radius:18px;padding:14px;cursor:pointer;display:flex;flex-direction:column;justify-content:space-between;min-height:86px;user-select:none;
  transition: transform .08s ease, background .15s ease, border-color .15s ease;}
.oddBtn:hover{background: rgba(0,0,0,.62);border-color: rgba(255,255,255,.18);}
.oddBtn:active{transform: translateY(1px);}
.oddBtn.selected{outline:2px solid rgba(167,139,250,.55);box-shadow:0 0 0 4px rgba(124,58,237,.18);}
.oddName{font-weight:950;font-size:15px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;}
.oddCoef{font-family:var(--mono);font-size:20px;font-weight:950;color: var(--purple2);}
.oddBtn.g .oddCoef{color: rgba(34,197,94,.95);}
.oddBtn.r .oddCoef{color: rgba(239,68,68,.95);}
.modalRow{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;margin-top:12px;padding-top:12px;border-top:1px solid rgba(255,255,255,.08);}
.miniPill{display:inline-flex;align-items:center;gap:8px;padding:8px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background: rgba(0,0,0,.20);color: rgba(255,255,255,.74);font-size:12px;white-space:nowrap;}
.miniPill input{width:130px;padding:8px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background: rgba(0,0,0,.26);color:rgba(255,255,255,.92);outline:none;font-size:12px;margin:0;}
.miniPill input:focus{border-color: rgba(167,139,250,.38);box-shadow:0 0 0 4px rgba(124,58,237,.16);}

/* case */
.caseBox{border:1px solid rgba(255,255,255,.12);background:linear-gradient(180deg, rgba(10,13,22,.78), rgba(7,9,15,.78));border-radius:18px;padding:12px;box-shadow:0 20px 64px rgba(0,0,0,.42);}
.caseStage{position:relative;height:228px;border-radius:16px;border:1px solid rgba(255,255,255,.12);background:
  radial-gradient(740px 280px at 18% 28%, rgba(43,76,255,.20), transparent 65%),
  radial-gradient(680px 260px at 82% 28%, rgba(173,63,255,.16), transparent 65%),
  linear-gradient(180deg, rgba(14,18,30,.94), rgba(8,11,20,.92));overflow:hidden;}
.caseStage::before,
.caseStage::after{
  content:"";
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  width:0;
  height:0;
  border-left:9px solid transparent;
  border-right:9px solid transparent;
  z-index:4;
  pointer-events:none;
}
.caseStage::before{top:8px;border-top:12px solid rgba(205,219,255,.95);filter:drop-shadow(0 0 8px rgba(202,214,255,.45));}
.caseStage::after{bottom:8px;border-bottom:12px solid rgba(205,219,255,.95);filter:drop-shadow(0 0 8px rgba(202,214,255,.45));}
.caseLine{position:absolute;top:16px;bottom:16px;left:50%;width:2px;transform:translateX(-1px);
  background:linear-gradient(180deg, transparent, rgba(225,233,255,.82), transparent);filter:drop-shadow(0 0 12px rgba(213,223,255,.28));pointer-events:none;z-index:3;}
.caseTrack{position:absolute;top:50%;left:0;transform:translateY(-50%);display:flex;gap:4px;align-items:center;will-change:transform;padding:0 28px;}
.caseItem{width:180px;height:192px;border-radius:14px;border:1px solid rgba(255,255,255,.16);background:linear-gradient(180deg, rgba(38,47,73,.96), rgba(24,31,52,.95));
  display:flex;flex-direction:column;align-items:stretch;justify-content:flex-start;box-shadow:0 18px 46px rgba(0,0,0,.52);overflow:hidden;user-select:none;position:relative;}
.caseItem::before{content:"";position:absolute;left:0;right:0;bottom:0;height:3px;background:rgba(170,183,255,.72);}
.caseItem .skinArt{height:120px;display:flex;align-items:center;justify-content:center;background:
  radial-gradient(220px 110px at 50% 5%, rgba(255,255,255,.15), transparent 70%),
  linear-gradient(155deg, rgba(255,255,255,.10), rgba(255,255,255,.02));}
.caseItem .skinIcon{display:flex;align-items:center;justify-content:center;filter:drop-shadow(0 10px 14px rgba(0,0,0,.45));}
.caseItem .skinIcon .iconSvg{width:54px;height:54px;vertical-align:0;margin:0;}
.caseItem .skinIcon .iconPoop{width:44px;height:44px;vertical-align:0;margin:0;filter: drop-shadow(0 0 10px rgba(0,0,0,.72));}
.caseItem .skinMeta{padding:8px 10px 0;line-height:1.2;}
.caseItem .skinName{font-size:15px;font-weight:950;color:rgba(234,240,255,.95);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
.caseItem .skinVariant{font-size:12px;color:rgba(173,188,228,.88);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;margin-top:2px;}
.caseItem .skinValue{margin-top:auto;padding:8px 10px 10px;font-family:var(--mono);font-size:15px;font-weight:950;color:rgba(237,243,255,.92);}
.caseItem.common{background:linear-gradient(180deg, rgba(36,50,92,.95), rgba(22,31,58,.95));}
.caseItem.common::before{background:rgba(120,151,255,.8);}
.caseItem.uncommon{background:linear-gradient(180deg, rgba(48,67,113,.95), rgba(26,40,70,.95));}
.caseItem.uncommon::before{background:rgba(138,219,255,.8);}
.caseItem.rare{background:linear-gradient(180deg, rgba(68,57,120,.95), rgba(38,31,71,.95));}
.caseItem.rare::before{background:rgba(186,146,255,.88);}
.caseItem.mythic{background:linear-gradient(180deg, rgba(87,47,107,.95), rgba(52,25,67,.95));}
.caseItem.mythic::before{background:rgba(255,126,244,.88);}
.caseItem.legendary{background:linear-gradient(180deg, rgba(110,66,34,.95), rgba(64,39,19,.95));}
.caseItem.legendary::before{background:rgba(255,194,94,.92);}
.caseItem.toneBlue{background:linear-gradient(180deg, rgba(36,50,110,.96), rgba(18,29,72,.95));}
.caseItem.toneBlue::before{background:rgba(120,169,255,.9);}
.caseItem.tonePurple{background:linear-gradient(180deg, rgba(78,52,136,.96), rgba(43,28,85,.95));}
.caseItem.tonePurple::before{background:rgba(196,143,255,.92);}
.caseItem.toneGold{background:linear-gradient(180deg, rgba(132,94,30,.96), rgba(86,60,18,.95));}
.caseItem.toneGold::before{background:rgba(255,213,119,.95);}
.caseItem.toneSilver{background:linear-gradient(180deg, rgba(110,117,133,.94), rgba(69,74,88,.95));}
.caseItem.toneSilver::before{background:rgba(216,226,246,.9);}
@media(max-width:760px){
  .caseStage{height:190px;}
  .caseTrack{gap:3px;padding:0 18px;}
  .caseItem{width:146px;height:160px;border-radius:12px;}
  .caseItem .skinArt{height:95px;}
  .caseItem .skinIcon .iconSvg{width:42px;height:42px;}
  .caseItem .skinIcon .iconPoop{width:34px;height:34px;}
  .caseItem .skinName{font-size:13px;}
  .caseItem .skinVariant{font-size:11px;}
  .caseItem .skinValue{font-size:13px;padding:7px 9px 9px;}
}
.probList{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:12px;}
@media(max-width:760px){.probList{grid-template-columns:1fr;}}
.prob{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:10px 12px;border-radius:14px;border:1px solid rgba(255,255,255,.10);background: rgba(0,0,0,.22);font-size:12px;}

.adminPlayersTools{display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin-bottom:10px;}
.adminPlayersTools .search{flex:1;min-width:260px;margin-top:0;}
.adminPlayersMeta{font-size:12px;color:var(--muted);}
.newBadge{display:inline-flex;align-items:center;justify-content:center;margin-left:8px;padding:2px 7px;border-radius:999px;font-size:10px;font-weight:1000;letter-spacing:.04em;border:1px solid rgba(34,197,94,.35);background:rgba(34,197,94,.16);color:rgba(173,255,208,.95);vertical-align:middle;}

.caseDropOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;padding:18px;background:rgba(4,7,14,.76);backdrop-filter:blur(8px);z-index:1002;opacity:0;}
.caseDropOverlay.show{display:flex;animation:caseDropFadeIn .22s ease forwards;}
.caseDropOverlay.closing{display:flex;animation:caseDropFadeOut .2s ease forwards;}
.caseDropCard{width:min(680px,100%);border-radius:22px;border:1px solid rgba(255,255,255,.14);background:linear-gradient(180deg, rgba(11,16,33,.96), rgba(8,12,24,.96));box-shadow:0 30px 80px rgba(0,0,0,.68);overflow:hidden;transform:translateY(10px) scale(.965);opacity:0;}
.caseDropOverlay.show .caseDropCard{animation:caseDropCardIn .28s cubic-bezier(.2,.78,.12,1) .03s forwards;}
.caseDropOverlay.closing .caseDropCard{animation:caseDropCardOut .18s ease forwards;}
@keyframes caseDropFadeIn{from{opacity:0;}to{opacity:1;}}
@keyframes caseDropCardIn{from{opacity:0;transform:translateY(10px) scale(.965);}to{opacity:1;transform:translateY(0) scale(1);}}
@keyframes caseDropFadeOut{from{opacity:1;}to{opacity:0;}}
@keyframes caseDropCardOut{from{opacity:1;transform:translateY(0) scale(1);}to{opacity:0;transform:translateY(8px) scale(.972);}}
.caseDropHd{display:flex;align-items:flex-start;justify-content:space-between;gap:12px;padding:18px 20px 12px;}
.caseDropTitle{display:flex;flex-direction:column;gap:2px;}
.caseDropTitle .k{font-size:12px;letter-spacing:.08em;text-transform:uppercase;color:rgba(174,190,232,.86);font-weight:900;}
.caseDropTitle .v{font-size:34px;line-height:1;font-weight:1000;color:rgba(242,247,255,.96);}
.caseDropClose{width:42px;height:42px;border-radius:12px;border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.03);color:rgba(230,238,255,.86);font-size:22px;cursor:pointer;}
.caseDropClose:hover{background:rgba(255,255,255,.08);}
.caseDropBody{padding:8px 20px 18px;display:grid;place-items:center;}
.caseDropItem{width:min(420px,100%);border-radius:18px;border:1px solid rgba(255,255,255,.14);position:relative;overflow:hidden;box-shadow:0 22px 62px rgba(0,0,0,.56);}
.caseDropItem .dropArt{height:210px;display:flex;align-items:center;justify-content:center;background:radial-gradient(270px 150px at 50% 10%, rgba(255,255,255,.20), transparent 72%);}
.caseDropItem .dropArt .iconSvg{width:120px;height:120px;margin:0;vertical-align:0;}
.caseDropItem .dropArt .iconPoop{width:98px;height:98px;margin:0;vertical-align:0;}
.caseDropItem .dropMeta{padding:16px 16px 20px;text-align:center;}
.caseDropItem .dropName{font-size:34px;font-weight:1000;line-height:1;color:rgba(241,247,255,.98);}
.caseDropItem .dropVariant{font-size:20px;font-weight:900;color:rgba(201,215,246,.95);margin-top:6px;}
.caseDropItem .dropValue{font-size:30px;font-weight:1000;color:rgba(146,240,128,.96);margin-top:10px;font-family:var(--mono);}
.caseDropItem .dropMiss{color:rgba(255,179,179,.96);}
.caseDropItem.toneBlue{background:linear-gradient(180deg, rgba(36,50,110,.96), rgba(18,29,72,.95));}
.caseDropItem.tonePurple{background:linear-gradient(180deg, rgba(78,52,136,.96), rgba(43,28,85,.95));}
.caseDropItem.toneGold{background:linear-gradient(180deg, rgba(132,94,30,.96), rgba(86,60,18,.95));}
.caseDropItem.toneSilver{background:linear-gradient(180deg, rgba(110,117,133,.94), rgba(69,74,88,.95));}
@media(max-width:760px){
  .caseDropCard{border-radius:16px;}
  .caseDropHd{padding:14px 14px 10px;}
  .caseDropTitle .v{font-size:24px;}
  .caseDropBody{padding:4px 14px 14px;}
  .caseDropItem .dropArt{height:160px;}
  .caseDropItem .dropArt .iconSvg{width:88px;height:88px;}
  .caseDropItem .dropArt .iconPoop{width:74px;height:74px;}
  .caseDropItem .dropMeta{padding:12px 12px 14px;}
  .caseDropItem .dropName{font-size:24px;}
  .caseDropItem .dropVariant{font-size:15px;}
  .caseDropItem .dropValue{font-size:22px;}
}

.toast{position:fixed;left:50%;transform:translateX(-50%);bottom:16px;padding:10px 12px;border-radius:999px;border:1px solid rgba(255,255,255,.14);
  background: rgba(0,0,0,.62);box-shadow: var(--shadow);backdrop-filter: blur(12px);display:none;max-width:calc(100% - 24px);
  white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:12.5px;z-index:1000;}
.toast.show{display:block;}

.recoveryBadge{
  position:fixed;
  right:14px;
  bottom:54px;
  padding:8px 10px;
  border-radius:999px;
  border:1px solid rgba(167,139,250,.34);
  background: rgba(0,0,0,.62);
  box-shadow: var(--shadow);
  backdrop-filter: blur(12px);
  color: rgba(255,255,255,.92);
  font-size:11.5px;
  font-weight:900;
  letter-spacing:.01em;
  z-index:1000;
  display:none;
  align-items:center;
  gap:7px;
}
.recoveryBadge .dot{
  width:8px;
  height:8px;
  border-radius:999px;
  background:rgba(167,139,250,.95);
  box-shadow:0 0 0 4px rgba(167,139,250,.16), 0 0 14px rgba(167,139,250,.45);
}
.recoveryBadge.show{display:inline-flex;}

/* =======================
   BLACKJACK (Shuffle-style)
   ======================= */

.bjWrap{
  display:grid;
  grid-template-columns: 300px 1fr;
  gap:18px;
  align-items:stretch;
}
@media(max-width:980px){
  .bjWrap{ grid-template-columns:1fr; }
}

.bjLeft{
  border:1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.22);
  border-radius:18px;
  padding:12px;
  box-shadow:0 16px 50px rgba(0,0,0,.45);
  position:relative;
  overflow:hidden;
}
.bjLeft::before{
  content:"";
  position:absolute; inset:-40%;
  background:
    radial-gradient(closest-side at 25% 20%, rgba(124,58,237,.22), transparent 60%),
    radial-gradient(closest-side at 75% 30%, rgba(239,68,68,.12), transparent 60%),
    conic-gradient(from 180deg, rgba(167,139,250,.12), transparent, rgba(239,68,68,.08), transparent);
  filter: blur(2px);
  pointer-events:none;
}

.bjBlock{
  position:relative;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.28);
  border-radius:16px;
  padding:12px;
  margin-top:10px;
  overflow:hidden;
}
.bjBlock:first-child{ margin-top:0; }

.bjTitle{
  font-weight:1000;
  letter-spacing:.18em;
  font-size:11px;
  text-transform:uppercase;
  color: rgba(255,255,255,.78);
  margin-bottom:10px;
}
.bjRow{
  display:flex; gap:10px; align-items:flex-end; flex-wrap:wrap;
}
.bjRow .miniPill{ margin-top:0; }

.bjSeg{
  display:flex; gap:10px;
}
.bjSeg .tab{ padding:10px 12px; border-radius:14px; }
.bjSeg .tab.active{ background:rgba(124,58,237,.22); border-color:rgba(167,139,250,.25); }

.bjBtnGrid{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:10px;
  margin-top:10px;
}
.bjBtn{
  border:1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.06);
  color: rgba(255,255,255,.92);
  padding:12px 12px;
  border-radius:16px;
  font-weight:1000;
  cursor:pointer;
  user-select:none;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  box-shadow:0 16px 50px rgba(0,0,0,.30);
}
.bjBtn:hover{ background: rgba(255,255,255,.09); }
.bjBtn:active{ transform: translateY(1px); }
.bjBtn:disabled{ opacity:.55; cursor:not-allowed; transform:none; }
/* availability pulses (outline only) */
.bjBtn.bjPulseDouble{
  border-color: rgba(234,179,8,.75);
  background: linear-gradient(145deg, rgba(234,179,8,.20), rgba(124,58,237,.22));
  box-shadow:
    0 0 0 3px rgba(234,179,8,.18),
    0 12px 40px rgba(0,0,0,.32),
    inset 0 1px 0 rgba(255,255,255,.14);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  animation: bjPulseDouble 1.5s ease-in-out infinite;
}
.bjBtn.bjPulseSplit{
  border-color: rgba(59,130,246,.75);
  background: linear-gradient(145deg, rgba(59,130,246,.20), rgba(124,58,237,.22));
  box-shadow:
    0 0 0 3px rgba(59,130,246,.18),
    0 12px 40px rgba(0,0,0,.32),
    inset 0 1px 0 rgba(255,255,255,.14);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  animation: bjPulseSplit 1.5s ease-in-out infinite;
}

@keyframes bjPulseDouble{
  0%,100%{
    box-shadow:
      0 0 0 3px rgba(234,179,8,.18),
      0 12px 40px rgba(0,0,0,.32),
      inset 0 1px 0 rgba(255,255,255,.14);
  }
  50%{
    box-shadow:
      0 0 0 6px rgba(234,179,8,.26),
      0 14px 46px rgba(0,0,0,.36),
      inset 0 1px 0 rgba(255,255,255,.16);
  }
}
@keyframes bjPulseSplit{
  0%,100%{
    box-shadow:
      0 0 0 3px rgba(59,130,246,.18),
      0 12px 40px rgba(0,0,0,.32),
      inset 0 1px 0 rgba(255,255,255,.14);
  }
  50%{
    box-shadow:
      0 0 0 6px rgba(59,130,246,.26),
      0 14px 46px rgba(0,0,0,.36),
      inset 0 1px 0 rgba(255,255,255,.16);
  }
}

.bjBtn.red{
  background: linear-gradient(135deg, rgba(239,68,68,.95), rgba(251,113,133,.82));
  border-color: rgba(255,255,255,.16);
}
.bjBtn.purple{
  background: linear-gradient(135deg, rgba(124,58,237,.95), rgba(167,139,250,.72));
  border-color: rgba(255,255,255,.16);
}
.bjBtn.green{
  background: linear-gradient(135deg, rgba(34,197,94,.95), rgba(134,239,172,.78));
  border-color: rgba(255,255,255,.16);
}

.bjActionMobile{display:none;gap:10px;margin-top:12px;}
.bjActionMobile .bjBtn{width:100%;justify-content:center;font-size:14px;padding:12px 12px;}
.bjActionMobile .full{grid-column: span 2;}
.bjActionMobile .barLabel{grid-column: span 2;font-size:11px;color:rgba(255,255,255,.65);letter-spacing:.16em;font-weight:900;text-transform:uppercase;}
.bjActionMobile .bjBetRow{grid-column: span 2;display:grid;grid-template-columns:1.2fr 1fr 1fr auto;gap:8px;align-items:end;}
.bjActionMobile .bjBetRow label{font-size:11px;color:var(--muted);font-weight:900;letter-spacing:.04em;display:block;margin-bottom:4px;}
.bjActionMobile .bjBetRow input{width:100%;padding:8px 10px;border-radius:12px;border:1px solid rgba(255,255,255,.14);background:rgba(0,0,0,.26);color:rgba(255,255,255,.92);font-size:13px;}
.bjActionMobile .bjBetRow .bjBtn{padding:11px 12px;min-width:92px;}
@media(max-width:700px){
  .bjActionMobile{display:grid;grid-template-columns:repeat(2,1fr);}
  .bjActionMobile .bjBtn{border-radius:14px;}
  .bjLeft .bjBlock:nth-child(1),
  .bjLeft .bjBlock:nth-child(2){display:none;}
  /* Overlap long card runs so they don't push down (player + dealer) */
  .bjHandCards.stacked, #bjDealerCards.stacked{gap:0;flex-wrap:nowrap;}
  .bjHandCards.stacked .bjCard, #bjDealerCards.stacked .bjCard{width:84px;}
  .bjHandCards.stacked .bjCard:not(:first-child), #bjDealerCards.stacked .bjCard:not(:first-child){margin-left:-46px;}
  .bjHandCards.stacked .bjSuit, .bjHandCards.stacked .bjPip,
  #bjDealerCards.stacked .bjSuit, #bjDealerCards.stacked .bjPip{opacity:1;}
}

.bjStage{
  border:1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.16);
  border-radius:18px;
  box-shadow:0 14px 55px rgba(0,0,0,.45);
  overflow:hidden;
  position:relative;
  min-height: 560px;
}
.bjStage::before{
  content:"";
  position:absolute;
  inset:-40%;
  background:
    radial-gradient(closest-side at 25% 25%, rgba(124,58,237,.18), transparent 60%),
    radial-gradient(closest-side at 75% 25%, rgba(239,68,68,.10), transparent 60%),
    conic-gradient(from 180deg, rgba(167,139,250,.08), transparent, rgba(239,68,68,.06), transparent);
  filter: blur(2px);
  pointer-events:none;
}

.bjTopInfo{
  position:relative;
  display:flex;
  justify-content:center;
  gap:10px;
  padding:12px;
  border-bottom:1px solid rgba(255,255,255,.08);
}
.bjChip{
  display:inline-flex;
  align-items:center;
  gap:8px;
  padding:8px 12px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.32);
  color: rgba(255,255,255,.88);
  font-weight:1000;
  box-shadow:0 18px 55px rgba(0,0,0,.55);
}
.bjChip .mono{ font-weight:1000; }

.bjArea{
  position:relative;
  padding:20px;
}
.bjLane{
  position:relative;
  display:flex;
  justify-content:center;
  align-items:flex-start;
  gap:18px;
  min-height: 220px; /* keep dealer/player zones equal height */
}
.bjLaneTitle{
  position:absolute;
  left:14px;
  top:14px;
  font-weight:1000;
  letter-spacing:.16em;
  text-transform:uppercase;
  font-size:11px;
  color: rgba(255,255,255,.58);
}
.bjLaneInner{
  margin-top:52px; /* drop cards lower so score pills stay visible */
  display:flex;
  justify-content:center;
  flex-wrap:wrap;
  gap:14px;
  align-items:flex-start;
  min-height: 160px; /* consistent card bed for both lanes */
}

/* Hide legacy player pill number (per-hand meta now shows totals) */
#bjPlayerPill{ display:none; }

#bjPlayerCards{
  display:flex;
  flex-direction:row;
  flex-wrap:wrap;
  align-items:flex-start;
  justify-content:center;
  gap:14px 28px; /* spread hands horizontally before stacking */
}

/* auto-scale player cards when many split hands */
#bjPlayerCards[data-hands="3"] .bjHandCards .bjCard{ transform: scale(.92); transform-origin: top center; }
#bjPlayerCards[data-hands="4"] .bjHandCards .bjCard{ transform: scale(.86); transform-origin: top center; }
#bjPlayerCards[data-hands="5"],
#bjPlayerCards[data-hands="6"],
#bjPlayerCards[data-hands="7"] .bjHandCards .bjCard{ transform: scale(.80); transform-origin: top center; }

.bjHandRow{
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:8px;
  min-width: 300px;
  flex: 1 1 46%;
  max-width: 48%;
  position:relative;
  transition: transform 220ms ease, opacity 180ms ease;
  background: rgba(255,255,255,.02);
  border-radius:14px;
  padding:6px 6px 8px;
}
.bjHandRow::before{
  content: attr(data-hand);
  position:absolute;
  left:-22px;
  top:50%;
  transform:translateY(-50%);
  font-size:11px;
  font-weight:1000;
  color:rgba(255,255,255,.50);
}
.bjHandRow.active{
  transform: translateY(2px) scale(1.02);
  opacity:1;
  box-shadow: 0 0 0 2px rgba(124,58,237,.28), 0 10px 28px rgba(0,0,0,.35);
}
.bjHandRow:not(.active){
  opacity:1;
}

.bjHandRow.active .bjCard{ opacity:1; filter:none; }
.bjHandRow:not(.active) .bjCard{ opacity:1; filter:none; }
.bjHandRow.active .bjHandMeta{ border-color: rgba(124,58,237,.35); background: rgba(124,58,237,.08); }
.bjHandRow:not(.active) .bjHandMeta{ opacity:1; }

.bjHandCards{
  display:flex;
  justify-content:center;
  gap:14px;
  flex-wrap:nowrap;
  min-height:165px; /* reserve space so bed doesn't jump when cards arrive */
  align-items:flex-start;
}
.bjHandCards .bjCard{transition:none;}
.bjHandCards.stacked .bjCard{transform: translateX(0);transition:none !important;}
.bjHandCards.stacked .bjCard:not(:first-child){transform-origin:left center;}
.bjHandCards.stacked .stackArrive{animation: stackArrive .18s ease-out;}
@keyframes stackArrive{from{transform: translateX(32px) scale(1.02);}to{transform: translateX(0) scale(1);} }
.bjHandCards.stacked, #bjDealerCards.stacked{gap:0;flex-wrap:nowrap;position:relative;}
.bjHandCards.stacked .bjCard, #bjDealerCards.stacked .bjCard{width:104px;}
.bjHandCards.stacked .bjCard:not(:first-child), #bjDealerCards.stacked .bjCard:not(:first-child){margin-left:0;}
.bjHandCards.stacked .bjSuit, .bjHandCards.stacked .bjPip,
#bjDealerCards.stacked .bjSuit, #bjDealerCards.stacked .bjPip{opacity:1;}
#bjDealerCards{min-height:205px;height:205px;display:flex;justify-content:center;align-items:flex-start;padding-top:14px;position:relative;}

@media(max-width:1100px){
  #bjPlayerCards{ justify-content:center; }
  .bjHandRow{ flex: 1 1 100%; max-width:100%; }
}

@media(max-width:640px){
  .bjArea{ padding:12px; }
  .bjStage{ min-height: 520px; }
  .bjLane{ gap:12px; min-height: 190px; }
  .bjLaneInner{ margin-top:44px; gap:10px; min-height:130px; }
  #bjPlayerCards{ gap:10px; }
  .bjHandRow{ min-width:230px; flex: 1 1 100%; max-width:100%; padding:6px 6px 10px; }
  .bjHandRow::before{ left:-16px; font-size:10px; }
  .bjHandMeta{ font-size:11px; padding:6px 9px; text-align:center; }
  .bjHandCards{ gap:10px; flex-wrap:wrap; }
  .bjDeck{ display:none; }
  .bjLaneTitle{ left:10px; top:10px; font-size:10px; }
  .bjScorePill{ top:10px; padding:6px 10px; font-size:13px; }
  .bjBtnGrid{ grid-template-columns:1fr; gap:8px; }
  .bjBtn{ padding:14px 14px; font-size:15px; }
  .bjRow{ gap:8px; }
}

.bjHandMeta{
  display:flex;
  align-items:center;
  gap:10px;
  padding:6px 10px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.28);
  font-weight:900;
  font-size:12px;
  color: rgba(255,255,255,.82);
}
.bjHandMeta .pill{
  margin:0;
}
.bjScorePill{
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  top:12px;
  padding:7px 12px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.35);
  font-weight:1000;
  color: rgba(255,255,255,.92);
  box-shadow:0 18px 55px rgba(0,0,0,.55);
}
.bjDivider{
  height:1px;
  background: rgba(255,255,255,.08);
  margin:10px 0;
}

.bjDeck{
  position:absolute;
  top:14px;
  right:14px;
  width:104px;
  height:145px;
  border-radius:16px;
  border:1px solid rgba(255,255,255,.14);
  background:
    linear-gradient(135deg, #4b2d7a 0%, #31224f 55%, #1a142f 100%);
  box-shadow:0 20px 45px rgba(0,0,0,.55);
  overflow:hidden;
  z-index:5;

  /* stacked cards illusion */
  box-shadow:
    0 18px 55px rgba(0,0,0,.55),
    7px 7px 0 rgba(255,255,255,.06),
    14px 14px 0 rgba(255,255,255,.035),
    21px 21px 0 rgba(255,255,255,.02),
    0 0 24px rgba(124,58,237,.16);
}

.bjDeck::before{
  content:"";
  position:absolute;
  inset:16px 14px 16px 14px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.16);
  box-shadow: inset 0 0 0 1px rgba(0,0,0,.45);
  pointer-events:none;
  background:
    url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='70' height='16'><text x='0' y='12' fill='rgba(255,255,255,0.55)' font-family='Arial' font-size='7' letter-spacing='2'>BET BET BET BET</text></svg>") 0 0 repeat,
    url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='70' height='16'><text x='0' y='12' fill='rgba(255,255,255,0.55)' font-family='Arial' font-size='7' letter-spacing='2'>BET BET BET BET</text></svg>") 35px 8px repeat;
  background-size: 70px 16px, 70px 16px;
}

.bjDeck::after{
  content:"𝑯𝒁";
  position:absolute;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:900;
  font-size:42px;
  color:rgba(245,240,255,.90);
  text-shadow:0 1px 10px rgba(0,0,0,.28);
  opacity:1;
  font-family: "Cambria Math", "Noto Sans Math", "DejaVu Sans", "Arial Black", sans-serif;
}
.bjDeck.bump{ animation: bjDeckBump .16s ease-out; }
@keyframes bjDeckBump{
  0%{ transform: translateY(0) scale(1); }
  50%{ transform: translateY(-2px) scale(1.03); }
  100%{ transform: translateY(0) scale(1); }
}

/* CARD 3D flip */
.bjCard{
  width:104px; height:148px;
  perspective: 1000px;
  position:relative;
}
.bjCardInner{
  width:100%; height:100%;
  position:relative;
  transform-style:preserve-3d;
  transition: transform .55s cubic-bezier(.2,.8,.2,1);
  will-change: transform;

  /* DEFAULT = BACK SIDE visible */
  transform: rotateY(180deg);
}

/* flipped = FACE visible */
.bjCard.flipped .bjCardInner{ transform: rotateY(0deg); }

.bjFace, .bjBack{
  position:absolute; inset:0;
  border-radius:14px;
  backface-visibility:hidden;
  border:1px solid rgba(0,0,0,.70);
  box-shadow:0 18px 55px rgba(0,0,0,.45);
  overflow:hidden;
}
.bjFace{
  background: rgba(255,255,255,.96);
  display:flex;
  flex-direction:column;
  padding:10px 10px 8px;
  color:#111;
}
.bjRank{
  font-weight:1000;
  font-size:26px;
  line-height:1;
}
.bjSuit{
  font-size:20px;
  margin-top:4px;
}
.bjPip{
  margin-top:auto;
  display:flex;
  justify-content:flex-end;
  font-weight:1000;
  opacity:.85;
}
.bjRed{ color:#b91c1c; }
.bjBlack{ color:#111827; }

.bjBack{
  transform: rotateY(180deg);
  border-color: rgba(255,255,255,.12);
  background:
    linear-gradient(135deg, #4b2d7a 0%, #31224f 55%, #1a142f 100%);
}
.bjBack::before{
  content:"";
  position:absolute; inset:16px 14px 16px 14px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.16);
  box-shadow: inset 0 0 0 1px rgba(0,0,0,.45);
  pointer-events:none;
  background:
    url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='70' height='16'><text x='0' y='12' fill='rgba(255,255,255,0.55)' font-family='Arial' font-size='7' letter-spacing='2'>BET BET BET BET</text></svg>") 0 0 repeat,
    url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='70' height='16'><text x='0' y='12' fill='rgba(255,255,255,0.55)' font-family='Arial' font-size='7' letter-spacing='2'>BET BET BET BET</text></svg>") 35px 8px repeat;
  background-size: 70px 16px, 70px 16px;
}
.bjBack::after{
  content:"𝑯𝒁";
  position:absolute; inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:920;
  font-size:42px;
  color:rgba(245,240,255,.93);
  text-shadow:0 1px 10px rgba(0,0,0,.30);
  font-family: "Cambria Math", "Noto Sans Math", "DejaVu Sans", "Arial Black", sans-serif;
}

/* Wind trail effect while dealing */
.bjTrail{
  position:absolute;
  inset:-10px;
  border-radius:18px;
  pointer-events:none;
  opacity:0;
  background:
    radial-gradient(closest-side at 30% 40%, rgba(255,255,255,.18), transparent 70%),
    radial-gradient(closest-side at 60% 60%, rgba(167,139,250,.18), transparent 70%);
  filter: blur(6px);
}
.bjCard.dealing .bjTrail{
  opacity:1;
  animation: bjTrailFade .28s ease-out forwards;
}
@keyframes bjTrailFade{
  from{ opacity:.9; transform: scale(1); }
  to{ opacity:0; transform: scale(1.08); }
}

/* Winner/Loser outlines */
.bjWin .bjFace, .bjWin .bjBack{
  box-shadow:0 0 0 6px rgba(34,255,94,.85), 0 0 16px 6px rgba(34,255,94,.35), 0 18px 55px rgba(0,0,0,.45);
}
.bjLose .bjFace, .bjLose .bjBack{
  box-shadow:0 0 0 6px rgba(255,68,68,.85), 0 0 16px 6px rgba(255,68,68,.35), 0 18px 55px rgba(0,0,0,.45);
}
.bjPush .bjFace, .bjPush .bjBack{
  box-shadow:0 0 0 6px rgba(245,158,11,.85), 0 0 16px 6px rgba(245,158,11,.35), 0 18px 55px rgba(0,0,0,.45);
}

/* Mines-style popup reused for BJ */
.bjCenterPop{
  position:absolute;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%) scale(.92);
  width:min(320px, 86%);
  padding:14px;
  border-radius:22px;
  background:
    radial-gradient(120% 120% at 30% 20%, rgba(255,255,255,.14), transparent 55%),
    rgba(12,12,18,.78);
  border:1px solid rgba(0,0,0,.85);
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,.10),
    0 26px 90px rgba(0,0,0,.75),
    0 0 28px rgba(34,197,94,.18);
  backdrop-filter: blur(14px);
  -webkit-backdrop-filter: blur(14px);
  display:none;
  z-index:200; /* keep win banner above stacked cards */
  text-align:center;
  pointer-events:none;
}
.bjCenterPop::before{
  content:"";
  position:absolute;
  inset:-2px;
  border-radius:24px;
  background:
    linear-gradient(135deg,
      rgba(34,197,94,.0),
      rgba(34,197,94,.55),
      rgba(34,197,94,.0)
    );
  filter: blur(10px);
  opacity:.45;
  z-index:0;
}
.bjCenterPop .inner{
  position:relative;
  z-index:1;
  border-radius:16px;
  background: rgba(255,255,255,.05);
  border:1px solid rgba(255,255,255,.14);
  padding:14px 14px 12px;
}
.bjCenterPop .label{
  font-size:11px;
  font-weight:900;
  letter-spacing:.18em;
  text-transform:uppercase;
  color: rgba(255,255,255,.70);
  margin-bottom:8px;
}
.bjCenterPop .amt{
  font-family: var(--mono);
  font-weight:1000;
  font-size:34px;
  line-height:1.05;
  color: rgba(255,255,255,.96);
}
.bjCenterPop .sub{
  margin-top:10px;
  font-size:12px;
  font-weight:800;
  color: rgba(255,255,255,.65);
  display:flex;
  align-items:center;
  justify-content:center;
  gap:8px;
}
.bjCenterPop .dot{
  width:8px;
  height:8px;
  border-radius:999px;
  background: rgba(34,197,94,.95);
  box-shadow: 0 0 10px rgba(34,197,94,.45);
}
.bjCenterPop.lose{
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,.08),
    0 26px 90px rgba(0,0,0,.75),
    0 0 28px rgba(239,68,68,.18);
}
.bjCenterPop.push{
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,.08),
    0 26px 90px rgba(0,0,0,.75),
    0 0 28px rgba(245,158,11,.22);
}
.bjCenterPop.lose::before{
  background:
    linear-gradient(135deg,
      rgba(239,68,68,.0),
      rgba(239,68,68,.55),
      rgba(239,68,68,.0)
    );
}
.bjCenterPop.push::before{
  background:
    linear-gradient(135deg,
      rgba(245,158,11,.0),
      rgba(245,158,11,.55),
      rgba(245,158,11,.0)
    );
}
.bjCenterPop.lose .dot{
  background: rgba(239,68,68,.95);
  box-shadow: 0 0 10px rgba(239,68,68,.45);
}
.bjCenterPop.push .dot{
  background: rgba(245,158,11,.95);
  box-shadow: 0 0 10px rgba(245,158,11,.45);
}
.plinkoWrap{display:grid;grid-template-columns:360px 1fr;gap:16px;align-items:start;}
@media(max-width:980px){.plinkoWrap{grid-template-columns:1fr;}}
.plinkoCard{background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.12);border-radius:18px;box-shadow:var(--shadow2);padding:16px;}
.plinkoGridCard{background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.55));border:1px solid rgba(255,255,255,.12);border-radius:18px;box-shadow:var(--shadow2);padding:14px;}
.plinkoControls{display:flex;flex-direction:column;gap:12px;}
.plinkoRow{display:flex;gap:10px;flex-wrap:wrap;align-items:flex-end;}
.plinkoRow input,.plinkoRow select{flex:1;}
.plinkoBtns{display:flex;gap:8px;flex-wrap:wrap;}
.plinkoBtn{border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:var(--text);padding:11px 12px;border-radius:14px;font-weight:900;cursor:pointer;user-select:none;transition:transform 120ms ease,background 160ms ease;flex:1;min-width:90px;}
.plinkoBtn:hover{background:rgba(255,255,255,.10);} .plinkoBtn:active{transform:translateY(1px);} .plinkoBtn.primary{background:linear-gradient(135deg, var(--purple), #3b82f6);border-color:rgba(255,255,255,.14);}
.plinkoStats{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:8px;}
.plinkoStat{padding:10px 12px;border-radius:14px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.04);display:flex;justify-content:space-between;align-items:center;font-weight:800;font-size:13px;}
.plinkoPayouts{display:flex;flex-wrap:wrap;gap:6px;margin-top:10px;}
.plinkoPill{padding:8px 10px;border-radius:10px;border:1px solid rgba(255,255,255,.12);font-weight:800;font-size:12px;}
.plinkoPill.win{border-color:rgba(34,197,94,.35);color:var(--green);} .plinkoPill.high{border-color:rgba(124,58,237,.35);color:var(--purple);} 
.plinkoCanvas{width:100%;height:640px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.65));display:block;}
@keyframes bjPopIn{
  0%   { opacity:0; transform:translate(-50%,-50%) scale(.86); }
  60%  { opacity:1; transform:translate(-50%,-50%) scale(1.03); }
  100% { opacity:1; transform:translate(-50%,-50%) scale(1); }
}
@keyframes bjPopOut{
  to { opacity:0; transform:translate(-50%,-50%) scale(.96); }
}
.bjCenterPop.show{ display:block; animation: bjPopIn .22s ease-out; }
.bjCenterPop.hide{ animation: bjPopOut .18s ease-in forwards; }

/* Make BJ area like Mines (not full stretched) */
#view-blackjack .sectionBd{
  max-width: 1180px;
  margin: 0 auto;
}
.bjWrap{
  max-width: 1180px;
  margin: 0 auto;
}
.bjStage{
  min-height: 560px;
}
</style>
</head>
<body>

<!-- SVG ICONS -->
<svg width="0" height="0" style="position:absolute">
  <defs>
    <linearGradient id="gYellow" x1="0" y1="0" x2="1" y2="1">
      <stop offset="0" stop-color="#fde68a"/><stop offset="1" stop-color="#f59e0b"/>
    </linearGradient>
    <linearGradient id="gBlue" x1="0" y1="0" x2="1" y2="1">
      <stop offset="0" stop-color="#93c5fd"/><stop offset="1" stop-color="#2563eb"/>
    </linearGradient>
    <filter id="fGlow" x="-50%" y="-50%" width="200%" height="200%">
      <feGaussianBlur stdDeviation="2.6" result="b"/>
      <feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge>
    </filter>
  </defs>
</svg>

<section class="authWrap" id="authWrap">
  <div class="authCard">
    <div class="authTop">
      <div class="mark"></div>
      <div><b>HANDZES.BET</b></div>
    </div>
    <div class="authBody">
      <div class="tabs">
        <button class="tab active" id="tabSignIn">Sign in</button>
        <button class="tab" id="tabSignUp">Sign up</button>
      </div>

      <div id="signInBox">
        <label>Email</label>
        <input id="inEmail" type="email" placeholder="Email" />
        <div style="height:10px"></div>
        <label>Password</label>
        <input id="inPass" type="password" placeholder="Password" />
        <div class="row">
          <button class="btn purple" id="btnSignIn" style="flex:1;">Sign in</button>
          <button class="btn" id="btnForgot" style="flex:1;">Reset password</button>
        </div>
      </div>

      <div id="signUpBox" style="display:none;">
        <label>Username</label>
        <input id="upName" placeholder="Username" />
        <div style="height:10px"></div>
        <label>Email</label>
        <input id="upEmail" type="email" placeholder="Email" />
        <div style="height:10px"></div>
        <label>Password</label>
        <input id="upPass" type="password" placeholder="Password" />
        <div class="row">
          <button class="btn purple" id="btnSignUp" style="flex:1;">Create account</button>
        </div>
      </div>

      <div class="small" id="setupHint" style="display:none;">
        Paste your Supabase URL + anon key in the code first.
      </div>
    </div>
  </div>
</section>

<div class="app" id="app">
  <aside class="sidebar">
    <div class="brand">
      <div class="logo"></div>
      <div>
        <b>HANDZES.BET</b>
        <small>games • sports • leaderboard</small>
      </div>
    </div>

    <div class="sideTitle">Menu</div>
    <button class="navBtn active" data-view="home"><span>Home</span><span class="chip" id="chipEvents">0</span></button>
    <button class="navBtn" data-view="games"><span>Games</span><span class="chip" id="chipGames">8</span></button>
    <button class="navBtn" data-view="sports"><span>Sports</span><span class="chip" id="chipSports">0</span></button>
    <button class="navBtn" data-view="leaderboard"><span>Leaderboard</span><span class="chip" id="chipLb">0</span></button>
    <button class="navBtn" data-view="bets"><span>My Bets</span><span class="chip" id="chipMyBets">0</span></button>
    <button class="navBtn" data-view="case"><span>Daily Case</span><span class="chip">🎁</span></button>

    <div id="adminNavWrap" style="display:none;">
      <div class="sideTitle">Admin</div>
      <button class="navBtn" data-view="admin"><span>Admin Panel</span><span class="chip ok">ADMIN</span></button>
    </div>

    <div class="sideTitle">Account</div>
    <div class="sideCard">
      <div class="pill"><span class="muted">User</span><span class="mono" id="meName">—</span></div>
      <div class="pill"><span class="muted">Balance</span><span><span class="mono" id="mePts">0.00</span> <span id="gemSmall"></span></span></div>
      <div class="pill"><span class="muted">Default stake</span>
        <span>
          <input id="defaultStake" type="number" min="0.01" step="0.01" value="0.10"
            style="width:110px;padding:8px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.26);color:rgba(255,255,255,.92);outline:none;font-size:12px;margin:0;"
            />
        </span>
      </div>
    </div>

    <div class="sideTitle">Actions</div>
    <button class="navBtn" id="signOutBtn"><span>Sign out</span><span class="chip">↩</span></button>
    <button class="navBtn" id="refreshBtn"><span>Refresh</span><span class="chip">R</span></button>
  </aside>

  <main class="main">
    <div class="topbar">
      <div class="walletMid"><span class="dot" id="adminDot"></span><span id="adminText">User</span></div>

      <div class="centerBrand">
        <div class="mark2"></div>
        <div class="title">HANDZES.BET</div>
        <div class="walletMid" title="Your balance">
          <span class="mono" id="topPts">0.00</span><span id="gemTop"></span>
        </div>
      </div>

      <div>
        <button class="profileBtn" id="profileBtn">
          <div class="avatar"></div>
          <div style="display:flex;flex-direction:column;line-height:1.1;align-items:flex-start;">
            <span style="font-weight:950;font-size:12.5px;" id="topUser">—</span>
            <span class="muted" style="font-size:11px;" id="topLevel">Level 1</span>
            <div class="levelWrap">
              <div class="levelBar"><div class="levelFill" id="lvlFill"></div></div>
              <div class="levelText"><span id="lvlProg">0.0/10.0 wager</span><span id="lvlPct">0%</span></div>
            </div>
          </div>
        </button>
      </div>
    </div>

    <div class="mobileNav" aria-label="Mobile navigation">
      <div class="mobileNavInner">
        <button class="navBtn active" data-view="home"><span>Home</span></button>
        <button class="navBtn" data-view="games"><span>Games</span></button>
        <button class="navBtn" data-view="blackjack"><span>Blackjack</span></button>
        <button class="navBtn" data-view="dice"><span>Dice</span></button>
        <button class="navBtn" data-view="roulette"><span>Roulette</span></button>
        <button class="navBtn" data-view="mines"><span>Mines</span></button>
        <button class="navBtn" data-view="sports"><span>Sports</span></button>
        <button class="navBtn" data-view="leaderboard"><span>Leaderboard</span></button>
        <button class="navBtn" data-view="bets"><span>My Bets</span></button>
        <button class="navBtn" data-view="case"><span>Daily Case</span></button>
        <button class="navBtn" data-view="admin" id="mobileAdminNav" style="display:none;"><span>Admin</span></button>
      </div>
    </div>

    <section id="view-home">
      <div class="section">
        <div class="sectionHd">
          <div><h3>HANDZES.BET GAMES</h3><div class="sub">Glowing demo tiles (no stock images).</div></div>
          <div class="chip">Games</div>
        </div>
        <div class="sectionBd"><div class="grid" id="gamesGridHome"></div></div>
      </div>

      <div class="section">
        <div class="sectionHd">
          <div><h3>Sports (your events)</h3><div class="sub">Click an event to bet.</div></div>
          <div class="chip"><span class="mono" id="sportsCountHome">0</span></div>
        </div>
        <div class="sectionBd"><div class="grid" id="sportsGridHome"></div></div>
      </div>
    </section>

    <section id="view-games" style="display:none;">
      <div class="section">
        <div class="sectionHd"><div><h3>Games</h3><div class="sub">Demo gallery.</div></div><div class="chip">8</div></div>
        <div class="sectionBd"><div class="grid" id="gamesGrid"></div></div>
      </div>
    </section>

    <section id="view-dice" style="display:none;">
      <div class="section">
        <div class="sectionHd"><div><h3>Dice</h3><div class="sub">50/50 roll. Win pays 1.95× (house edge).</div></div><div class="chip">LIVE</div></div>
        <div class="sectionBd">
          <div class="row" style="align-items:flex-end;">
            <div style="width:220px;">
              <label>Stake</label>
              <input id="diceStake" type="number" min="0.01" step="0.01" value="0.10"/>
            </div>
            <div style="width:220px;">
              <label>Pick</label>
              <select id="dicePick">
                <option value="low">LOW (1-49)</option>
                <option value="high">HIGH (50-100)</option>
              </select>
            </div>
            <button class="btn purple" id="diceRollBtn">Roll</button>
            <div class="miniPill"><span class="muted">Roll</span><span class="mono" id="diceRollOut">—</span></div>
            <div class="miniPill"><span class="muted">Result</span><span class="mono" id="diceResOut">—</span></div>
          </div>
        </div>
      </div>
    </section>

    <section id="view-roulette" style="display:none;">
      <div class="section">
        <div class="sectionHd"><div><h3>Roulette</h3><div class="sub">Red/Black pays 1.95×. Green pays 14×.</div></div><div class="chip">LIVE</div></div>
        <div class="sectionBd">
          <div class="row" style="align-items:flex-end;">
            <div style="width:220px;">
              <label>Stake</label>
              <input id="rouStake" type="number" min="0.01" step="0.01" value="0.10"/>
            </div>
            <div style="width:220px;">
              <label>Bet</label>
              <select id="rouPick">
                <option value="red">RED (1.95×)</option>
                <option value="black">BLACK (1.95×)</option>
                <option value="green">GREEN (14×)</option>
              </select>
            </div>
            <button class="btn purple" id="rouSpinBtn">Spin</button>
            <div class="miniPill"><span class="muted">Spin</span><span class="mono" id="rouOut">—</span></div>
            <div class="miniPill"><span class="muted">Result</span><span class="mono" id="rouRes">—</span></div>
          </div>
          <div class="sub" style="margin-top:10px;">Wheel: 0 = green, 1-18 = red, 19-36 = black (simple).</div>
        </div>
      </div>
    </section>

    <section id="view-mines" style="display:none;">
      <div class="section">
        <div class="sectionHd">
          <div><h3>Mines</h3><div class="sub">Pick gems, avoid bombs. Cashout anytime.</div></div>
          <div class="chip">LIVE</div>
        </div>

        <div class="sectionBd">
          <div class="row" style="align-items:flex-end;">
            <div style="width:220px;">
              <label>Stake</label>
              <input id="minesStake" type="number" min="0.01" step="0.01" value="0.10"/>
            </div>

            <div style="width:220px;">
              <label>Bombs</label>
              <select id="minesBombs">
              </select>
            </div>

            <button class="btn purple" id="minesStartBtn">Start</button>
            <button class="btn" id="minesCashBtn" disabled>Cashout</button>

            <div class="miniPill">
              <span class="muted">Current payout</span>
              <span class="mono" id="minesPayoutTop">—</span>
            </div>

            <div class="miniPill"><span class="muted">Status</span><span class="mono" id="minesStatus">—</span></div>
          </div>

          <div class="minesWrap">
            <div style="position:relative; max-width:520px;">
              <div id="minesGrid"></div>
              <div class="minesCenterPop" id="minesCenterPop">
                <span class="p" style="left:22px; top:22px;"></span>
                <span class="p" style="right:26px; top:28px;"></span>
                <span class="p" style="left:28px; bottom:22px;"></span>
                <span class="p" style="right:30px; bottom:18px;"></span>

                <div class="inner">
                  <div class="label" id="minesPopLabel">CASHED OUT</div>

                  <!-- ✅ payout biggest -->
                  <div class="amt" id="minesPopAmt">0.00</div>

                  <!-- ✅ multiplier smaller (if you want it) -->
                  <div class="mx" id="minesPopMx">x1.00</div>

                  <div class="sub"><span class="dot"></span><span id="minesPopSub">added to balance</span></div>
                </div>
              </div>
            </div>

            <div class="minesRight">
              <div class="minesRightHd">
                <div class="minesRightTitle">MULTIPLIER</div>
                <div class="minesRightSub"><span id="minesRightBombs">—</span> bombs • <span id="minesRightPicks">0</span> picks</div>
              </div>

              <div class="minesLadder" id="minesLadder"></div>

              <div class="minesXFloat" id="minesXFloat">x1.00</div>
            </div>
          </div>

          <div class="sub" style="margin-top:10px;">25 tiles. Multipliers update every correct pick. Auto cashout when all safe tiles are found.</div>
        </div>
      </div>
    </section>

    <section id="view-plinko" style="display:none;">
      <div id="plinko-embed"></div>
    </section>

    <section id="view-plinko-old" style="display:none;">
      <!-- Old Plinko HTML here (kept hidden) -->
    </section>

    <section id="view-sports" style="display:none;">
      <div class="section">
        <div class="sectionHd"><div><h3>Sports</h3><div class="sub">Your created events with coefficients.</div></div><div class="chip"><span class="mono" id="chipSports2">0</span></div></div>
        <div class="sectionBd"><div class="grid" id="eventsGrid"></div></div>
      </section>

      <section id="view-leaderboard" style="display:none;">
        <div class="section">
          <div class="sectionHd"><div><h3>Leaderboard</h3><div class="sub">Monthly wager (resets by calendar month) and last 24h wager.</div></div><div class="chip"><span class="mono" id="lbMonth">—</span></div></div>
          <div class="sectionBd lbWrap">
            <div class="lbCard">
              <div class="lbCardHd">
                <div>
                  <div class="lbLabel">Monthly</div>
                  <div class="lbSub">Current month total</div>
                </div>
                <div class="chip"><span class="mono" id="lbCountMonth">0</span></div>
              </div>
              <table class="lbTable">
                <thead><tr><th>#</th><th>User</th><th>Wager (this month)</th><th>Level</th></tr></thead>
                <tbody id="lbBody"><tr><td colspan="4" class="muted">Loading…</td></tr></tbody>
              </table>
            </div>
          </div>
        </div>
      </section>

      <section id="view-bets" style="display:none;">
        <div class="section">
          <div class="sectionHd"><div><h3>My Bets</h3><div class="sub">Bets for your account.</div></div><div class="chip"><span class="mono" id="myBetsCount">0</span></div></div>
          <div class="sectionBd">
            <table>
              <thead><tr><th>Time</th><th>Event</th><th>Pick</th><th>Stake</th><th>Coef</th><th>Status</th><th>Payout</th></tr></thead>
              <tbody id="myBetsBody"><tr><td colspan="7" class="muted">No bets yet.</td></tr></tbody>
            </table>
          </div>
        </div>
      </section>

      <section id="view-case" style="display:none;">
        <div class="section">
          <div class="sectionHd">
            <div><h3>Daily Case</h3><div class="sub">Open after you wager 10 (this month). Admin can test anytime.</div></div>
            <div class="chip" id="caseStatus">—</div>
          </div>
          <div class="sectionBd">
            <div class="caseBox">
              <div class="row" style="justify-content:space-between;align-items:center;margin-top:0;">
                <div class="miniPill"><span class="muted">Next case in</span><span class="mono" id="caseCountdown">—</span></div>
                <div class="miniPill"><span class="muted">Requirement</span><span class="mono" id="caseReq">0.00 / 10.00</span><span id="gemReq"></span></div>
              </div>
              <div style="height:10px"></div>
              <div class="caseStage">
                <div class="caseLine"></div>
                <div class="caseTrack" id="caseTrack"></div>
              </div>
              <div class="row" style="margin-top:12px;justify-content:space-between;">
                <button class="btn purple" id="openCaseBtn">Open case</button>
              </div>

              <div class="probList">
                <div class="prob"><span>70% → win 100</span><span class="mono">100</span></div>
                <div class="prob"><span>10% → win 250</span><span class="mono">250</span></div>
                <div class="prob"><span>7.5% → win 500</span><span class="mono">500</span></div>
                <div class="prob"><span>2.5% → win 1000</span><span class="mono">1000</span></div>
                <div class="prob"><span>9% → win nothing</span><span class="mono">0.00</span></div>
                <div class="prob"><span>1% → win 10000</span><span class="mono">10000</span></div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section id="view-admin" style="display:none;">
        <div class="section">
          <div class="sectionHd"><div><h3>Admin Panel</h3><div class="sub">Only the Handzes account can see this.</div></div><div class="chip ok">ADMIN</div></div>
          <div class="sectionBd">
            <div class="section" style="margin-top:0;">
              <div class="sectionHd"><div><h3>Give points</h3><div class="sub">Select a user and set/add points (decimals supported).</div></div></div>
              <div class="sectionBd">
                <label>Registered users</label>
                <select id="userSelect"></select>
                <div class="row">
                  <div style="width:180px;">
                    <label>Set points</label>
                    <input id="ptsSet" type="number" step="0.01" value="10.00"/>
                  </div>
                  <button class="btn purple" id="setPtsBtn">Set</button>
                  <button class="btn" id="resetUserLevelBtn">Reset selected level</button>
                  <div style="width:180px;">
                    <label>Add amount</label>
                    <input id="ptsAdd" type="number" step="0.01" value="0.10"/>
                  </div>
                  <button class="btn" id="addBtn">Add</button>
                </div>
                <div class="small" id="adminUserHint"></div>
              </div>
            </div>

            <div class="section">
              <div class="sectionHd">
                <div>
                  <h3>All players</h3>
                  <div class="sub">Live list with balance and online status.</div>
                  <div class="sub" id="adminPlayersLastSync">Last refresh: —</div>
                </div>
                <div class="row" style="margin-top:0;gap:8px;align-items:center;">
                  <div class="chip"><span class="mono" id="adminPlayersCount">0</span></div>
                  <button class="btn red" id="resetAllStatsBtn">Reset everything</button>
                  <button class="btn" id="repairMonthWagerBtn">Repair monthly wager</button>
                  <button class="btn" id="resetAllLevelsBtn">Reset all levels</button>
                  <button class="btn" id="reloadAdminPlayersBtn">Reload</button>
                </div>
              </div>
              <div class="sectionBd">
                <div class="adminPlayersTools">
                  <input class="search" id="adminPlayersSearch" placeholder="Search by username or gmail" />
                  <button class="btn" id="adminPlayersToggleBtn" style="display:none;">Show all</button>
                  <div class="adminPlayersMeta" id="adminPlayersMeta">Showing 0</div>
                </div>
                <table>
                  <thead><tr><th>User</th><th>Email</th><th>Balance</th><th>Status</th><th>Last seen</th></tr></thead>
                  <tbody id="adminPlayersBody"><tr><td colspan="5" class="muted">Loading…</td></tr></tbody>
                </table>
              </div>
            </div>

            <div class="section">
              <div class="sectionHd"><div><h3>Create sports event</h3><div class="sub">2+ options with coefficients.</div></div></div>
              <div class="sectionBd">
                <div class="row">
                  <div style="flex:1;min-width:260px;">
                    <label>Event name</label>
                    <input id="evName" placeholder="Race / Match / Player A vs Player B"/>
                  </div>
                  <div style="width:180px;">
                    <label>Status</label>
                    <select id="evStatus">
                      <option value="open">open</option>
                      <option value="closed">closed</option>
                    </select>
                  </div>
                </div>
                <div style="margin-top:10px;">
                  <label>Description</label>
                  <input id="evDesc" placeholder="Rules, best-of-3…"/>
                </div>
                <div class="row" style="margin-top:10px;align-items:center;">
                  <div style="flex:1;">
                    <label>Options</label>
                    <div class="muted" style="font-size:12px;margin-top:4px;">Add 2+ options</div>
                  </div>
                  <button class="btn" id="addOptBtn">Add option</button>
                </div>
                <div id="optsBox" style="margin-top:10px;"></div>
                <div class="row" style="margin-top:12px;">
                  <button class="btn purple" id="createEventBtn">Create</button>
                </div>
                <div id="adminEventsBox" class="small"></div>
              </div>
            </div>

            <div class="section">
              <div class="sectionHd">
                <div><h3>Manage events</h3><div class="sub">Open/Close/Finish, select winner, delete.</div></div>
                <button class="btn" id="reloadAdminEventsBtn">Reload</button>
              </div>
              <div class="sectionBd">
                <div id="adminEventsList" class="small muted">Loading…</div>
              </div>
            </div>

            <div class="section" style="margin-top:14px;">
              <div class="sectionHd">
                <div>
                  <h3>SQL (run once)</h3>
                  <div class="sub">Run this once in Supabase → SQL Editor if you get DB/RLS errors.</div>
                </div>
              </div>
              <div class="sectionBd">
<pre style="margin:0;white-space:pre-wrap;font-family:var(--mono);font-size:12px;color:rgba(255,255,255,.82);">
create extension if not exists pgcrypto;

create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  email text unique,
  display_name text,
  avatar_seed text default 'p1',
  pts numeric(14,2) default 10.00,
  lifetime_wager numeric(14,2) default 0,
  month_wager numeric(14,2) default 0,
  month_key text default to_char(now(),'YYYY-MM'),
  level int default 1,
  last_seen timestamptz,
  last_case_open date,
  created_at timestamptz default now()
);

alter table public.profiles
  add column if not exists last_seen timestamptz;

create table if not exists public.events (
  id bigint generated by default as identity primary key,
  name text not null,
  description text default ''::text,
  status text default 'open'::text,
  created_at timestamptz default now(),
  created_by uuid references auth.users(id),
  winner_option_id bigint null
);

create table if not exists public.event_options (
  id bigint generated by default as identity primary key,
  event_id bigint not null references public.events(id) on delete cascade,
  label text not null,
  coef numeric(10,2) not null default 2.00
);

do $$
begin
  alter table public.events
    add constraint events_winner_fk foreign key (winner_option_id)
    references public.event_options(id) on delete set null;
exception when duplicate_object then null;
end $$;

create table if not exists public.bets (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references auth.users(id) on delete cascade,
  event_id bigint references public.events(id) on delete cascade,
  option_id bigint references public.event_options(id) on delete cascade,
  event_name text,
  opt_name text,
  stake numeric(14,2),
  coef numeric(10,2),
  status text default 'pending',
  payout numeric(14,2) default 0,
  created_at timestamptz default now()
);

create table if not exists public.app_state (
  id int primary key,
  current_month text,
  last_awarded_month text,
  updated_at timestamptz default now()
);
insert into public.app_state (id, current_month, last_awarded_month)
values (1, to_char(now(),'YYYY-MM'), null)
on conflict (id) do nothing;

alter table public.profiles disable row level security;
alter table public.events disable row level security;
alter table public.event_options disable row level security;
alter table public.bets disable row level security;
alter table public.app_state disable row level security;
</pre>
            </div>
          </div>

        </div>
      </div>
    </section>

    <section id="view-blackjack" style="display:none;">
      <div class="section">
        <div class="sectionHd">
          <div>
            <h3>Blackjack</h3>
            <div class="sub">Shuffle-style UI • Flip animation • Wind deal • Side bets</div>
          </div>
          <div class="chip">LIVE</div>
        </div>

        <div class="sectionBd">
          <div class="bjWrap">

            <!-- LEFT PANEL -->
            <div class="bjLeft">

              <div class="bjBlock">
                <div class="bjTitle">Bet</div>

                <div class="bjRow" style="justify-content:space-between;">
                  <div class="miniPill"><span class="muted">Balance</span><span class="mono" id="bjBal">0.00</span><span id="bjGem"></span></div>
                  <div class="miniPill"><span class="muted">Shoe</span><span class="mono" id="bjShoe">—</span></div>
                </div>

                <div style="height:10px"></div>


                <label>Standard bet</label>
                <div style="display:flex; flex-direction:column; gap:6px;">
                  <input id="bjStake" type="number" min="0.01" step="0.01" value="0.10" style="width:100%; font-size:15px; padding:12px 12px;"/>
                  <div style="display:flex; gap:8px;">
                    <button class="bjBtn" type="button" id="bjStakeMin" style="flex:1; min-width:90px;">Min</button>
                    <button class="bjBtn" type="button" id="bjStakeMax" style="flex:1; min-width:90px;">Max</button>
                  </div>
                  <div style="display:flex; gap:8px;">
                    <button class="bjBtn" type="button" id="bjStakeHalf" style="flex:1; min-width:90px;">1/2</button>
                    <button class="bjBtn" type="button" id="bjStakeDouble" style="flex:1; min-width:90px;">2x</button>
                  </div>
                </div>

                <div style="height:10px"></div>

                <label>Side bets</label>
                <div class="bjRow" style="align-items:center;">
                  <div style="flex:1; min-width:220px;">
                    <div class="pill" style="margin-top:6px;">
                      <span class="muted">Perfect Pairs</span>
                      <input id="bjSidePairs" type="number" min="0" step="0.01" value="0.00"
                             style="width:120px; margin:0; padding:8px 10px; border-radius:999px;" />
                    </div>
                    <div class="pill">
                      <span class="muted">Bust Out</span>
                      <input id="bjSideBust" type="number" min="0" step="0.01" value="0.00"
                             style="width:120px; margin:0; padding:8px 10px; border-radius:999px;" />
                    </div>
                  </div>
                </div>

                <div class="sub" style="margin-top:10px;">
                  Perfect Pair pays <b>25×</b> (same rank & suit), Colored Pair pays <b>12×</b> (same rank & color), Mixed Pair pays <b>6×</b> (same rank). Bust Out pays <b>2×</b> (3-4 cards), <b>4×</b> (5 cards), <b>15×</b> (6 cards), <b>50×</b> (7 cards), <b>250×</b> (8+ cards) if dealer busts.
                </div>

                <div class="bjRow" style="margin-top:10px; justify-content:space-between;">
                  <button class="bjBtn purple" id="bjBetBtn" style="flex:1; justify-content:center;">Bet</button>
                </div>
              </div>

              <div class="bjBlock">
                <div class="bjTitle">Actions</div>

                <div class="bjBtnGrid">
                  <button class="bjBtn green" id="bjHitBtn" disabled>
                    <span>Hit</span><span class="chip">🂠</span>
                  </button>

                  <button class="bjBtn red" id="bjStandBtn" disabled>
                    <span>Stand</span><span class="chip">✋</span>
                  </button>

                  <button class="bjBtn" id="bjSplitBtn" disabled>
                    <span>Split</span><span class="chip">⇄</span>
                  </button>

                  <button class="bjBtn" id="bjDoubleBtn" disabled>
                    <span>Double</span><span class="chip">⧉</span>
                  </button>
                </div>

                <div class="sub" style="margin-top:10px;">
                  Split only available when first two player cards have same rank.
                </div>
              </div>

              <div class="bjBlock">
                <div class="bjTitle">Rules</div>
                <div class="sub">
                  Dealer stands on 17. Blackjack pays 3:2. (Demo logic)
                </div>
              </div>

            </div>

            <!-- RIGHT STAGE -->
            <div class="bjStage" id="bjStage">
              <div class="bjDeck" id="bjDeck" title="Shoe"></div>

              <div class="bjTopInfo">
                <div class="bjChip"><span class="muted">Dealer</span><span class="mono" id="bjDealerScore">—</span></div>
                <div class="bjChip"><span class="muted">Player</span><span class="mono" id="bjPlayerScore">—</span></div>
                <div class="bjChip"><span class="muted">Hand</span><span class="mono" id="bjHandNo">1</span></div>
              </div>

              <div class="bjArea">
                <div class="bjLane">
                  <div class="bjLaneTitle">Dealer</div>
                  <div class="bjScorePill" id="bjDealerPill">—</div>
                  <div class="bjLaneInner" id="bjDealerCards"></div>
                </div>

                <div class="bjDivider"></div>

                <div class="bjLane">
                  <div class="bjLaneTitle">Player</div>
                  <div class="bjScorePill" id="bjPlayerPill">—</div>
                  <div class="bjLaneInner" id="bjPlayerCards"></div>
                </div>

                <div class="bjCenterPop" id="bjCenterPop">
                  <div class="inner">
                    <div class="label" id="bjPopLabel">WIN</div>
                    <div class="amt" id="bjPopAmt">0.00</div>
                    <div class="sub"><span class="dot" id="bjPopDot"></span><span id="bjPopSub">added to balance</span></div>
                  </div>
                </div>

              </div>

              <div class="bjActionMobile">
                <div class="barLabel">Bet & Side Bets</div>
                <div class="bjBetRow">
                  <div>
                    <label for="bjStakeM">Bet</label>
                    <div style="display:flex; flex-direction:column; gap:6px;">
                      <input id="bjStakeM" type="number" min="0.01" step="0.01" value="0.10" style="width:100%; font-size:15px; padding:12px 12px;"/>
                      <div style="display:flex; gap:6px;">
                        <button class="bjBtn" type="button" id="bjStakeMinM" style="flex:1; min-width:80px;">Min</button>
                        <button class="bjBtn" type="button" id="bjStakeMaxM" style="flex:1; min-width:80px;">Max</button>
                      </div>
                      <div style="display:flex; gap:6px;">
                        <button class="bjBtn" type="button" id="bjStakeHalfM" style="flex:1; min-width:80px;">1/2</button>
                        <button class="bjBtn" type="button" id="bjStakeDoubleM" style="flex:1; min-width:80px;">2x</button>
                      </div>
                    </div>
                  </div>
                  <div>
                    <label for="bjSidePairsM">Pairs</label>
                    <input id="bjSidePairsM" type="number" min="0" step="0.01" value="0.00" />
                  </div>
                  <div>
                    <label for="bjSideBustM">Bust</label>
                    <input id="bjSideBustM" type="number" min="0" step="0.01" value="0.00" />
                  </div>
                  <button class="bjBtn purple" id="bjBetBtnM">Bet</button>
                </div>
                <button class="bjBtn green" id="bjHitBtnM" disabled><span>Hit</span><span class="chip">🂠</span></button>
                <button class="bjBtn red" id="bjStandBtnM" disabled><span>Stand</span><span class="chip">✋</span></button>
                <button class="bjBtn" id="bjSplitBtnM" disabled><span>Split</span><span class="chip">⇄</span></button>
                <button class="bjBtn" id="bjDoubleBtnM" disabled><span>Double</span><span class="chip">⧉</span></button>
              </div>
            </div>

          </div>
        </div>
      </div>
    </section>

  </main>
</div>

<!-- Event modal -->
<div class="overlay" id="overlay">
  <div class="modal">
    <div class="modalHd">
      <div style="min-width:0;">
        <h4 id="mTitle">Event</h4>
        <p id="mDesc" class="muted"></p>
      </div>
      <button class="closeBtn" id="closeModal">✕</button>
    </div>
    <div class="modalBd">
      <div class="row" style="justify-content:space-between;gap:10px;flex-wrap:wrap;">
        <span class="tag" id="mStatus">OPEN</span>
        <span class="miniPill"><span class="muted">Your balance</span><span class="mono" id="mBal">0.00</span><span id="gemBal"></span></span>
      </div>
      <div class="oddsGrid" id="mOdds"></div>
      <div class="modalRow">
        <div class="row" style="gap:10px;">
          <div class="miniPill"><span class="muted">Stake</span><input id="mStake" type="number" min="0.01" step="0.01" value="0.10"/></div>
          <div class="miniPill"><span class="muted">Potential payout</span><span class="mono" id="mPayout">—</span></div>
        </div>
        <div class="row" style="gap:10px;justify-content:flex-end;">
          <button class="btn" id="mCancel">Cancel</button>
          <button class="btn green" id="mConfirm" disabled>Confirm bet</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Profile modal -->
<div class="overlay" id="profileOverlay">
  <div class="modal" style="width:min(760px,100%);">
    <div class="modalHd">
      <div><h4>Profile</h4><p class="muted">Edit username + picture</p></div>
      <button class="closeBtn" id="closeProfile">✕</button>
    </div>
    <div class="modalBd">
      <div class="row" style="gap:10px;align-items:flex-end;">
        <div style="display:flex;align-items:center;gap:12px;">
          <div class="avatar" id="pAvatar" style="width:44px;height:44px;border-radius:16px;"></div>
          <div style="display:flex;flex-direction:column;gap:6px;">
            <label>Username</label>
            <input id="pUserEdit" placeholder="Username" style="width:220px"/>
          </div>
        </div>

        <div class="miniPill"><span class="muted">Balance</span><span class="mono" id="pBal">0.00</span><span id="gemProf"></span></div>
        <div class="miniPill"><span class="muted">Level</span><span class="mono" id="pLevel">1</span></div>
      </div>

      <div style="margin-top:12px;">
        <label>Profile picture</label>
        <div class="row" style="gap:10px;margin-top:6px;">
          <button class="btn" data-ava="p1">Purple</button>
          <button class="btn" data-ava="p2">Red</button>
          <button class="btn" data-ava="p3">Blue</button>
          <button class="btn" data-ava="p4">Green</button>
          <button class="btn" data-ava="p5">Gold</button>
        </div>
        <div class="row" style="justify-content:flex-end;margin-top:10px;">
          <button class="btn purple" id="pSaveBtn">Save profile</button>
        </div>
      </div>

      <div class="section" style="margin-top:12px;">
        <div class="sectionHd"><div><h3>Stats</h3><div class="sub">Calculated from your wagers.</div></div></div>
        <div class="sectionBd">
          <div class="row" style="gap:10px;">
            <div class="miniPill"><span class="muted">Wager (this month)</span><span class="mono" id="pMonthW">0.00</span><span id="gemMW"></span></div>
            <div class="miniPill"><span class="muted">Wager (lifetime)</span><span class="mono" id="pLifeW">0.00</span><span id="gemLW"></span></div>
            <div class="miniPill"><span class="muted">Bets</span><span class="mono" id="pBets">0</span></div>
          </div>
        </div>
      </div>
      <div class="row" style="justify-content:flex-end;margin-top:12px;">
        <button class="btn" id="pCloseBtn">Close</button>
      </div>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>
<div class="caseDropOverlay" id="caseDropOverlay">
  <div class="caseDropCard" role="dialog" aria-modal="true" aria-labelledby="caseDropTitle">
    <div class="caseDropHd">
      <div class="caseDropTitle">
        <div class="k">Your drop</div>
        <div class="v" id="caseDropTitle">Case opening</div>
      </div>
      <button class="caseDropClose" id="caseDropClose" aria-label="Close drop popup">×</button>
    </div>
    <div class="caseDropBody">
      <div class="caseDropItem" id="caseDropItem"></div>
    </div>
  </div>
</div>
<div class="recoveryBadge" id="recoveryBadge"><span class="dot"></span><span id="recoveryBadgeText">Recovery mode</span></div>

<script type="module">
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const SUPABASE_URL = "https://jolpzszotsaglwghbyaq.supabase.co";
const SUPABASE_ANON_KEY = "sb_publishable_H5RpNuvRJu3-HyTiB24RJQ_LzJRe4WA";

const ADMIN_USERS = {
  "handzes.deal@gmail.com": "Handzes",
  "matas1649@gmail.com": "MatasAdmin",
};

function getAdminDisplayNameByEmail(email){
  const key = String(email||"").toLowerCase();
  return ADMIN_USERS[key] || null;
}

function isAdminEmail(email){
  return !!getAdminDisplayNameByEmail(email);
}

const $ = (id)=>document.getElementById(id);
const esc = (s)=>String(s ?? "").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
const to2 = (n)=> (Math.round((Number(n)+Number.EPSILON)*100)/100).toFixed(2);
const clamp2 = (n)=> Math.max(0, Math.round(Number(n)*100)/100);

const toastEl = $("toast");
const toast = (msg)=>{ toastEl.textContent=msg; toastEl.classList.add("show"); clearTimeout(toastEl._t); toastEl._t=setTimeout(()=>toastEl.classList.remove("show"), 2600); };
const recoveryBadgeEl = $("recoveryBadge");
const recoveryBadgeTextEl = $("recoveryBadgeText");

function showRecoveryBadge(text="Recovery mode", ms=2200){
  if(!recoveryBadgeEl) return;
  if(recoveryBadgeTextEl) recoveryBadgeTextEl.textContent = text;
  recoveryBadgeEl.classList.add("show");
  clearTimeout(recoveryBadgeEl._t);
  recoveryBadgeEl._t = setTimeout(()=>{
    recoveryBadgeEl.classList.remove("show");
  }, Math.max(600, Number(ms)||2200));
}

const gemYellow = () => `<svg class="iconSvg glow" viewBox="0 0 24 24" style="filter:url(#fGlow)"><path fill="url(#gYellow)" d="M12 2 4.2 9.2 12 22l7.8-12.8z"/><path fill="rgba(255,255,255,.35)" d="M12 2 9 9.2h6z"/></svg>`;

// Bigger gem specifically for MINES grid
const gemYellowMines = () => `<svg class="minesGemSvg glow" viewBox="0 0 24 24" style="filter:url(#fGlow)"><path fill="url(#gYellow)" d="M12 2 4.2 9.2 12 22l7.8-12.8z"/><path fill="rgba(255,255,255,.35)" d="M12 2 9 9.2h6z"/></svg>`;

// Custom red glowing bomb (no emoji)
const bombRed = () => `<svg class="minesBombSvg bombPulseSvg" viewBox="0 0 64 64"><defs><radialGradient id="bombCore" cx="35%" cy="30%" r="70%"><stop offset="0" stop-color="rgba(255,255,255,.55)"/><stop offset="0.25" stop-color="rgba(251,113,133,.95)"/><stop offset="1" stop-color="rgba(239,68,68,.95)"/></radialGradient><radialGradient id="bombShadow" cx="35%" cy="35%" r="75%"><stop offset="0" stop-color="rgba(0,0,0,.0)"/><stop offset="1" stop-color="rgba(0,0,0,.65)"/></radialGradient></defs><path d="M44 14c7-6 12-4 14-2" fill="none" stroke="rgba(255,255,255,.75)" stroke-width="4" stroke-linecap="round"/><circle cx="60" cy="11" r="3.5" fill="rgba(255,255,255,.9)"/><circle cx="58.5" cy="9.5" r="2.2" fill="rgba(239,68,68,.95)"/><path d="M32 12c8 0 14 4 14 9v4H18v-4c0-5 6-9 14-9z" fill="rgba(0,0,0,.55)" stroke="rgba(255,255,255,.18)" stroke-width="2" /><circle cx="32" cy="38" r="20" fill="url(#bombCore)" stroke="rgba(0,0,0,.65)" stroke-width="2"/><circle cx="32" cy="38" r="20" fill="url(#bombShadow)" opacity=".55"/><path d="M22 28c3-5 8-8 14-8" fill="none" stroke="rgba(255,255,255,.55)" stroke-width="4" stroke-linecap="round" opacity=".55"/></svg>`;
const gemBlue = () => `<svg class="iconSvg glow" viewBox="0 0 24 24" style="filter:url(#fGlow)"><path fill="url(#gBlue)" d="M12 2 4.2 9.2 12 22l7.8-12.8z"/><path fill="rgba(255,255,255,.35)" d="M12 2 9 9.2h6z"/></svg>`;
const poop = () => `<svg class="iconPoop" viewBox="0 0 24 24"><path fill="#8b5e34" d="M10 3c0 1-1 2-2 2 0 0 1 1 1 2 0 0-2 1-2 3 0 0 2 0 2 2H7c-2 0-3 2-3 4s2 5 8 5 8-2 8-5-1-4-3-4h-2c0-2 2-2 2-2 0-2-2-3-2-3 0-1 1-2 1-2-1 0-2-1-2-2-1 1-1 2-2 2s-1-1-2-2z"/></svg>`;

const AVA = {
  p1: "radial-gradient(16px 16px at 30% 30%, rgba(167,139,250,.98), rgba(124,58,237,.55))",
  p2: "radial-gradient(16px 16px at 30% 30%, rgba(251,113,133,.95), rgba(239,68,68,.55))",
  p3: "radial-gradient(16px 16px at 30% 30%, rgba(147,197,253,.95), rgba(37,99,235,.55))",
  p4: "radial-gradient(16px 16px at 30% 30%, rgba(134,239,172,.95), rgba(34,197,94,.50))",
  p5: "radial-gradient(16px 16px at 30% 30%, rgba(253,230,138,.95), rgba(245,158,11,.55))",
};
function applyAvatar(el, seed){
  const bg = AVA[seed] || AVA.p1;
  el.style.background = bg;
  el.style.boxShadow = "0 10px 28px rgba(0,0,0,.55)";
  el.style.border = "1px solid rgba(255,255,255,.16)";
}

$("gemSmall").innerHTML = gemBlue();
$("gemTop").innerHTML = gemBlue();
$("gemReq").innerHTML = gemBlue();
$("gemBal").innerHTML = gemBlue();
$("gemProf").innerHTML = gemBlue();
$("gemMW").innerHTML = gemBlue();
$("gemLW").innerHTML = gemBlue();

// Ensure Plinko can call into host even if the real handler isn't defined yet.
// Calls will be queued and drained once the real `plinkoSetBalance` is installed.
window._plinkoBalanceQueue = window._plinkoBalanceQueue || [];
if (typeof window.plinkoSetBalance !== 'function') {
  window.plinkoSetBalance = function (nb) {
    try { window._plinkoBalanceQueue.push(nb); } catch (e) { /* noop */ }
  };
}

const keysOk = !SUPABASE_URL.includes("PASTE_") && !SUPABASE_ANON_KEY.includes("PASTE_");
$("setupHint").style.display = keysOk ? "none" : "";

const supabase = keysOk ? createClient(SUPABASE_URL, SUPABASE_ANON_KEY) : null;
if(!keysOk){ $("authWrap").classList.add("show"); toast("Paste Supabase keys in index.html"); }

function setAuthTab(which){
  const isIn = which==="in";
  $("tabSignIn").classList.toggle("active", isIn);
  $("tabSignUp").classList.toggle("active", !isIn);
  $("signInBox").style.display = isIn ? "" : "none";
  $("signUpBox").style.display = isIn ? "none" : "";
}
$("tabSignIn").onclick=()=>setAuthTab("in");
$("tabSignUp").onclick=()=>setAuthTab("up");

let session=null, meProfile=null, isAdmin=false, events=[], myBets=[], usersList=[];
let pendingPlinkoBalance = null;
let pendingPlinkoPersistBalance = null;
let presenceTimer = null;
let adminPlayersPollTimer = null;
let adminProfilesChannel = null;
let livePresenceChannel = null;
let onlineSignalChannel = null;
const ADMIN_SEEN_CACHE_KEY = "admin_seen_cache_v1";
const adminRealtimeSeenMap = new Map();
const adminBalanceSnapshotMap = new Map();
const livePresenceOnlineSet = new Set();
const liveSignalOnlineSet = new Set();
let adminPlayersLoading = false;
let adminPlayersPending = false;
let adminPlayersShowAll = false;
let adminPlayersSearchText = "";
let adminPlayersCache = [];

function loadAdminSeenCache(){
  try{
    const raw = localStorage.getItem(ADMIN_SEEN_CACHE_KEY);
    if(!raw) return;
    const obj = JSON.parse(raw);
    if(!obj || typeof obj !== "object") return;
    Object.entries(obj).forEach(([uid, iso])=>{
      if(uid && iso) adminRealtimeSeenMap.set(uid, String(iso));
    });
  }catch(_){ }
}

function saveAdminSeenCache(){
  try{
    const obj = {};
    for(const [uid, iso] of adminRealtimeSeenMap.entries()) obj[uid] = iso;
    localStorage.setItem(ADMIN_SEEN_CACHE_KEY, JSON.stringify(obj));
  }catch(_){ }
}

function markAdminSeen(uid, whenIso){
  if(!uid) return;
  adminRealtimeSeenMap.set(uid, whenIso || new Date().toISOString());
  saveAdminSeenCache();
}

function isAdminViewOpen(){
  return document.getElementById("view-admin")?.style.display !== "none";
}

function syncLivePresenceState(){
  if(!livePresenceChannel) return;
  const state = livePresenceChannel.presenceState() || {};
  livePresenceOnlineSet.clear();
  for(const [key, metas] of Object.entries(state)){
    if(key) livePresenceOnlineSet.add(String(key));
    const arr = Array.isArray(metas) ? metas : [];
    for(const meta of arr){
      const uid = String(meta?.user_id || key || "");
      if(uid){
        livePresenceOnlineSet.add(uid);
        markAdminSeen(uid, new Date().toISOString());
      }
    }
  }
  if(isAdmin && isAdminViewOpen()) loadAdminPlayers();
}

function startLivePresence(){
  stopLivePresence();
  if(!supabase || !session?.user?.id) return;

  livePresenceChannel = supabase.channel("handzes-live-presence", {
    config: { presence: { key: String(session.user.id) } },
  });

  livePresenceChannel
    .on("presence", { event:"sync" }, ()=>{
      syncLivePresenceState();
    })
    .on("presence", { event:"join" }, ({ key })=>{
      if(key){
        livePresenceOnlineSet.add(String(key));
        markAdminSeen(String(key), new Date().toISOString());
      }
      if(isAdmin && isAdminViewOpen()) loadAdminPlayers();
    })
    .on("presence", { event:"leave" }, ({ key })=>{
      if(key) livePresenceOnlineSet.delete(String(key));
      if(isAdmin && isAdminViewOpen()) loadAdminPlayers();
    })
    .subscribe(async (status)=>{
      if(status === "SUBSCRIBED"){
        try{
          await livePresenceChannel.track({
            user_id: String(session.user.id),
            email: String(session.user.email || "").toLowerCase(),
            online_at: new Date().toISOString(),
          });
        }catch(_){ }
      }
    });
}

function stopLivePresence(){
  if(!supabase || !livePresenceChannel) {
    livePresenceOnlineSet.clear();
    return;
  }
  try{ livePresenceChannel.untrack(); }catch(_){ }
  try{ supabase.removeChannel(livePresenceChannel); }catch(_){ }
  livePresenceChannel = null;
  livePresenceOnlineSet.clear();
}

function sendOnlineSignal(online=true){
  try{
    if(!onlineSignalChannel || !session?.user?.id) return;
    onlineSignalChannel.send({
      type: "broadcast",
      event: "online_signal",
      payload: {
        user_id: String(session.user.id),
        email: String(session.user.email || "").toLowerCase(),
        pts: Number(meProfile?.pts || 0),
        online: !!online,
        at: new Date().toISOString(),
      },
    });
  }catch(_){ }
}

function startOnlineSignalChannel(){
  stopOnlineSignalChannel();
  if(!supabase || !session?.user?.id) return;

  onlineSignalChannel = supabase.channel("handzes-online-signal");
  onlineSignalChannel
    .on("broadcast", { event:"online_signal" }, ({ payload })=>{
      try{
        const uid = String(payload?.user_id || "");
        const emailLc = String(payload?.email || "").toLowerCase();
        const at = String(payload?.at || new Date().toISOString());
        const isOnline = !!payload?.online;
        const pts = Number(payload?.pts);

        if(uid){
          if(isOnline){
            liveSignalOnlineSet.add(uid);
            markAdminSeen(uid, at);
          } else {
            liveSignalOnlineSet.delete(uid);
          }
        }

        let row = uid ? document.querySelector(`#adminPlayersBody tr[data-uid="${uid}"]`) : null;
        if(!row && emailLc) row = document.querySelector(`#adminPlayersBody tr[data-email="${emailLc}"]`);
        if(row){
          const balCell = row.querySelector('[data-col="balance"]');
          const statusCell = row.querySelector('[data-col="status"]');
          const seenCell = row.querySelector('[data-col="seen"]');
          if(balCell && Number.isFinite(pts)) balCell.textContent = to2(pts);
          if(statusCell) statusCell.innerHTML = `<span class="tag ${isOnline ? "open" : "closed"}">${isOnline ? "ONLINE" : "OFFLINE"}</span>`;
          if(seenCell) seenCell.textContent = isOnline ? "Now" : fmtLastSeen(at);
        }
      }catch(_){ }
    })
    .subscribe((status)=>{
      if(status === "SUBSCRIBED") sendOnlineSignal(true);
    });
}

function stopOnlineSignalChannel(){
  try{ sendOnlineSignal(false); }catch(_){ }
  if(!supabase || !onlineSignalChannel){
    liveSignalOnlineSet.clear();
    return;
  }
  try{ supabase.removeChannel(onlineSignalChannel); }catch(_){ }
  onlineSignalChannel = null;
  liveSignalOnlineSet.clear();
}

loadAdminSeenCache();

// Centralized host balance setter so embedded apps can listen for changes.
function setHostBalance(newPts){
  if(!meProfile) return;
  meProfile.pts = Number(newPts);
  // keep a global reference for embedded apps that read `window.meProfile`
  try{ window.meProfile = meProfile; }catch(_){ }
  try{ updateMeUI(); }catch(e){}
  try{ refreshAdminPlayerRowSelf(); }catch(_){ }
  try{ window.dispatchEvent(new CustomEvent('hostBalanceChanged', { detail: Number(newPts) })); }catch(e){}
}

function refreshAdminPlayerRowSelf(){
  const uid = session?.user?.id;
  const em = String(session?.user?.email||"").toLowerCase();
  if(!uid && !em) return;
  let row = uid ? document.querySelector(`#adminPlayersBody tr[data-uid="${uid}"]`) : null;
  if(!row && em) row = document.querySelector(`#adminPlayersBody tr[data-email="${em}"]`);
  if(!row) return;
  const balCell = row.querySelector('[data-col="balance"]');
  const statusCell = row.querySelector('[data-col="status"]');
  const seenCell = row.querySelector('[data-col="seen"]');
  if(balCell && meProfile) balCell.textContent = to2(Number(meProfile.pts||0));
  if(statusCell) statusCell.innerHTML = `<span class="tag open">ONLINE</span>`;
  if(seenCell) seenCell.textContent = "Now";
}

function updateAdminPlayersSyncStamp(){
  const el = $("adminPlayersLastSync");
  if(!el) return;
  const now = new Date();
  el.textContent = `Last refresh: ${now.toLocaleTimeString([], { hour:"2-digit", minute:"2-digit", second:"2-digit" })}`;
}

function renderAdminPlayersTable(){
  const body = $("adminPlayersBody");
  if(!body) return;

  const query = String(adminPlayersSearchText || "").trim().toLowerCase();
  const sorted = [...adminPlayersCache].sort((a,b)=>{
    if(a.online !== b.online) return a.online ? -1 : 1;
    if(a.lastSeenTs !== b.lastSeenTs) return b.lastSeenTs - a.lastSeenTs;
    return a.name.localeCompare(b.name);
  });

  const filtered = query
    ? sorted.filter((p)=> p.nameLc.includes(query) || p.emailLc.includes(query))
    : sorted;

  const useLimit = !adminPlayersShowAll;
  const visible = useLimit ? filtered.slice(0,10) : filtered;

  body.innerHTML = visible.length ? visible.map((p)=>`
    <tr data-uid="${p.id}" data-email="${esc(p.emailLc)}">
      <td>${esc(p.name||"Player")}${p.isNew ? `<span class="newBadge">NEW</span>` : ""}</td>
      <td>${esc(p.email||"")}</td>
      <td class="mono" data-col="balance">${to2(Number(p.pts||0))}</td>
      <td data-col="status"><span class="tag ${p.statusClass}">${p.statusText}</span></td>
      <td class="mono" data-col="seen">${esc(p.seenText)}</td>
    </tr>`).join("") : `<tr><td colspan="5" class="muted">No players found.</td></tr>`;

  const toggleBtn = $("adminPlayersToggleBtn");
  if(toggleBtn){
    const canToggle = filtered.length > 10;
    toggleBtn.style.display = canToggle ? "" : "none";
    toggleBtn.textContent = adminPlayersShowAll ? "Show top 10" : "Show all";
  }

  const meta = $("adminPlayersMeta");
  if(meta){
    if(!filtered.length) meta.textContent = "Showing 0";
    else if(adminPlayersShowAll || filtered.length <= 10) meta.textContent = `Showing ${visible.length} of ${filtered.length}`;
    else meta.textContent = `Showing 10 of ${filtered.length}`;
  }
}

function patchAdminPlayerRowFromProfile(profile){
  if(!profile) return;
  const uid = profile.id;
  const em = String(profile.email||"").toLowerCase();
  let row = uid ? document.querySelector(`#adminPlayersBody tr[data-uid="${uid}"]`) : null;
  if(!row && em) row = document.querySelector(`#adminPlayersBody tr[data-email="${em}"]`);
  if(!row) return;

  const ptsNow = Number(profile.pts ?? NaN);
  if(Number.isFinite(ptsNow)){
    const balCell = row.querySelector('[data-col="balance"]');
    if(balCell) balCell.textContent = to2(ptsNow);
    if(uid) adminBalanceSnapshotMap.set(uid, ptsNow);
  }
}
// ✅ MP3 cashout sound
const cashoutSound = new Audio("./sounds/cashout.mp3");
cashoutSound.preload = "auto";
cashoutSound.volume = 0.85;

// Browsers require "user gesture" before sound can play.
// This unlocks audio on the first click/tap anywhere.
let __audioUnlocked = false;
function unlockAudioOnce(){
  if(__audioUnlocked) return;
  __audioUnlocked = true;
  try{
    // unlock WebAudio too (for your sfx beeps)
    const ctx = window.__sfxCtx || (window.__sfxCtx = new (window.AudioContext||window.webkitAudioContext)());
    if(ctx && ctx.state === "suspended") ctx.resume();

    // unlock HTMLAudio
    cashoutSound.muted = true;
    cashoutSound.play().then(()=>{
      cashoutSound.pause();
      cashoutSound.currentTime = 0;
      cashoutSound.muted = false;
    }).catch(()=>{
      cashoutSound.muted = false;
    });
  }catch(_){}
}
window.addEventListener("pointerdown", unlockAudioOnce, { once:true });
window.addEventListener("keydown", unlockAudioOnce, { once:true });


function sfx(freq=520, dur=0.06, type="sine", gain=0.04){
  try{
    const ctx = window.__sfxCtx || (window.__sfxCtx = new (window.AudioContext||window.webkitAudioContext)());
    const o=ctx.createOscillator(); const g=ctx.createGain();
    o.type=type; o.frequency.value=freq; g.gain.value=gain;
    o.connect(g); g.connect(ctx.destination);
    o.start(); o.stop(ctx.currentTime+dur);
  }catch(_){}
}
function sfxBomb(){
  try{
    const ctx = window.__sfxCtx || (window.__sfxCtx = new (window.AudioContext||window.webkitAudioContext)());
    const o=ctx.createOscillator(); const g=ctx.createGain();
    o.type="sawtooth";
    o.frequency.setValueAtTime(220, ctx.currentTime);
    o.frequency.exponentialRampToValueAtTime(60, ctx.currentTime+0.18);
    g.gain.setValueAtTime(0.08, ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime+0.22);
    o.connect(g); g.connect(ctx.destination);
    o.start(); o.stop(ctx.currentTime+0.23);
  }catch(_){}
}
function sfxGem(){
  sfx(880,0.06,"triangle",0.03);
  setTimeout(()=>sfx(1180,0.05,"triangle",0.025), 40);
}

/* ✅ MONEY/CASHOUT SOUND (MP3) */
function sfxCashout(){
  try{
    unlockAudioOnce();            // make sure audio is unlocked
    cashoutSound.currentTime = 0; // replay instantly
    cashoutSound.play();
  }catch(_){}
}


function monthKey(d=new Date()){
  const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,"0"); return `${y}-${m}`;
}
function todayISO(){
  const d=new Date(); const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,"0"), day=String(d.getDate()).padStart(2,"0"); return `${y}-${m}-${day}`;
}
function computeLevel(lifeW){ return 1 + Math.floor(Number(lifeW||0)/10); }

function updateLevelUI(){
  const life = Number(meProfile?.lifetime_wager||0);
  const storedLevel = Math.floor(Number(meProfile?.level || 0));
  const lvl = storedLevel > 0 ? storedLevel : computeLevel(life);
  const prog = life % 10;
  const pct = Math.max(0, Math.min(100, (prog/10)*100));
  $("topLevel").textContent = `Level ${lvl}`;
  $("lvlFill").style.width = pct.toFixed(1)+"%";
  $("lvlProg").textContent = `${prog.toFixed(1)}/10.0 wager`;
  $("lvlPct").textContent = `${pct.toFixed(0)}%`;
}

function updateMeUI(){
  $("meName").textContent = meProfile?.display_name || "—";
  $("topUser").textContent = meProfile?.display_name || "—";
  $("mePts").textContent = to2(meProfile?.pts||0);
  $("topPts").textContent = to2(meProfile?.pts||0);
  updateLevelUI();
  applyAvatar(document.querySelector(".avatar"), meProfile?.avatar_seed||"p1");
  $("adminDot").style.background = isAdmin ? "var(--green)" : "var(--purple2)";
  $("adminDot").style.boxShadow = isAdmin ? "0 0 0 4px rgba(34,197,94,.14)" : "0 0 0 4px rgba(167,139,250,.14)";
  $("adminText").textContent = isAdmin ? "Admin" : "User";
  $("adminNavWrap").style.display = isAdmin ? "" : "none";
  const mobileAdmin=$("mobileAdminNav");
  if(mobileAdmin) mobileAdmin.style.display = isAdmin ? "" : "none";
}

function setView(v){
  try{ sessionStorage.setItem(LAST_VIEW_KEY, String(v||"home")); }catch(_){ }
  document.querySelectorAll(".navBtn[data-view]").forEach(b=>b.classList.toggle("active", b.dataset.view===v));
  ["home","games","dice","roulette","mines","blackjack","plinko","sports","leaderboard","bets","case","admin"].forEach(id=>{
    const el=$("view-"+id); if(el) el.style.display=(id===v)?"":"none";
  });
  if(!meProfile && session?.user){ ensureProfileReady(); }
  if(window.innerWidth<=900){
    window.scrollTo({ top: 0, behavior: "smooth" });
  }
  if(v==="leaderboard") refreshLeaderboard();
  if(v==="admin") {
    loadUsersList();
    loadAdminPlayers();
    loadAdminEvents();
    startAdminPlayersRealtime();
    if (adminPlayersPollTimer) clearInterval(adminPlayersPollTimer);
    adminPlayersPollTimer = setInterval(()=>{
      if (document.getElementById("view-admin")?.style.display !== "none") loadAdminPlayers();
    }, 1000);
  } else if (adminPlayersPollTimer) {
    clearInterval(adminPlayersPollTimer);
    adminPlayersPollTimer = null;
    stopAdminPlayersRealtime();
  }
  if(v==="case") refreshCaseUI();
  if(v==="blackjack") bjOnViewEnter();
  if(v==="plinko"){
    // Ensure embedded Plinko starts from the real profile balance.
    try {
      if (meProfile) {
        setHostBalance(Number(meProfile.pts || 0));
      } else if (session?.user) {
        ensureProfileReady().then(() => {
          if (meProfile) setHostBalance(Number(meProfile.pts || 0));
        }).catch(() => {});
      }
    } catch (_) {}

    // Always expose/refresh host API for embedded Plinko sync (even if already mounted)
    window.plinkoSetBalance = async function (newBalance) {
      try {
        const nb = Number(newBalance);
        if (isNaN(nb)) return;
        if (!meProfile && window.meProfile) meProfile = window.meProfile;
        if (!meProfile) {
          try { await ensureProfileReady(); } catch (_) {}
          if (!meProfile && window.meProfile) meProfile = window.meProfile;
        }
        if (!meProfile) {
          pendingPlinkoBalance = nb;
          return;
        }

        const oldPts = Number(meProfile.pts || 0);
        const diff = Math.round((nb - oldPts) * 100) / 100;
        if (diff === 0) return;

        const oldLife = Number(meProfile.lifetime_wager || 0);
        const oldMonth = Number(meProfile.month_wager || 0);

        const stake = diff < 0 ? Math.abs(diff) : 0;
        const newLife = clamp2(oldLife + stake);
        const newMonth = clamp2(oldMonth + stake);
        const newLvl = computeLevel(newLife);

        meProfile.pts = nb;
        if (stake > 0) {
          meProfile.lifetime_wager = newLife;
          meProfile.month_wager = newMonth;
          meProfile.level = newLvl;
        }
        setHostBalance(nb);

        if (!supabase || !session || !session.user || !session.user.id) {
          pendingPlinkoPersistBalance = nb;
          return;
        }

        if (diff < 0) {
          const { error } = await supabase.from('profiles').update({
            pts: nb,
            lifetime_wager: newLife,
            month_wager: newMonth,
            month_key: monthKey(),
            level: newLvl,
          }).eq('id', session.user.id);
          if (error) {
            pendingPlinkoPersistBalance = nb;
            setHostBalance(oldPts);
            meProfile.lifetime_wager = oldLife;
            meProfile.month_wager = oldMonth;
            meProfile.level = computeLevel(oldLife);
            try{ window.meProfile = meProfile; }catch(_){ }
            try{ updateMeUI(); }catch(_){ }
          }
          if (!error) pendingPlinkoPersistBalance = null;
          return;
        }
        if (diff > 0) {
          const { error } = await supabase.from('profiles').update({ pts: nb }).eq('id', session.user.id);
          if (error) {
            pendingPlinkoPersistBalance = nb;
            setHostBalance(oldPts);
          }
          if (!error) pendingPlinkoPersistBalance = null;
          return;
        }
      } catch (e) {
        console.error('plinkoSetBalance error', e);
      }
    };

    // Bind fallback outgoing listener once.
    if (!window._plinkoOutgoingListenerBound) {
      window._plinkoOutgoingListenerBound = true;
      try {
        window.addEventListener('plinkoOutgoingBalance', (ev) => {
          try {
            const nb = Number(ev?.detail);
            if (isNaN(nb)) return;
            if (!meProfile && window.meProfile) meProfile = window.meProfile;
            if (!meProfile) {
              pendingPlinkoBalance = nb;
              return;
            }
            setHostBalance(nb);
          } catch (err) {
            console.error('plinkoOutgoingBalance handler', err);
          }
        });
      } catch (err) {}
    }

    // If loader script hasn't run yet, run it
    const embed = document.getElementById("plinko-embed");
    if (embed && !embed.querySelector('#svelte-plinko-root')) {
      // Fetch the Svelte build index, extract entry script names and CSS, then load them.
      const plinkoBuildBase = new URL('./games/plinko/build/', window.location.href);
      fetch(new URL('index.html', plinkoBuildBase).toString())
        .then((r) => r.text())
        .then((html) => {
          // Create embed root
          embed.innerHTML = '<div id="svelte-plinko-root"></div>';

          // Find entry filenames for start/app (they change per build)
          const startMatch = html.match(/entry\/(start\.[^"'<>]+\.js)/);
          const appMatch = html.match(/entry\/(app\.[^"'<>]+\.js)/);

          // Find CSS asset hrefs under _app/immutable/assets
          const css = Array.from(html.matchAll(/href="(\.\/\_app\/immutable\/assets\/[^"]+\.css)"/g)).map(
            (m) => m[1].replace(/^\.\//, ''),
          );

          // Inject CSS links (absolute to build folder)
          css.forEach((href) => {
            const abs = new URL(href, plinkoBuildBase).toString();
            if (!document.querySelector('link[href="' + abs + '"]')) {
              const link = document.createElement('link');
              link.rel = 'stylesheet';
              link.href = abs;
              document.head.appendChild(link);
            }
          });

          if (startMatch && appMatch) {
            const startPath = new URL('_app/immutable/entry/' + startMatch[1], plinkoBuildBase).toString();
            const appPath = new URL('_app/immutable/entry/' + appMatch[1], plinkoBuildBase).toString();

            const script = document.createElement('script');
            script.type = 'module';
            script.textContent = `
              import('${startPath}').then(kit => {
                import('${appPath}').then(app => {
                  try{
                    kit.start(app, document.getElementById('svelte-plinko-root'), {
                      node_ids: [0, 3], data: [null, null], form: null, error: null
                    });
                  }catch(e){ console.error('plinko start error', e); }
                });
              });
            `;
            document.body.appendChild(script);
          } else {
            console.error('Plinko loader: could not find entry scripts in build index.html');
          }

            // Drain any queued plinko balance updates that happened before the real handler was installed
            try {
              if (window._plinkoBalanceQueue && window._plinkoBalanceQueue.length) {
                const q = window._plinkoBalanceQueue.slice();
                window._plinkoBalanceQueue = [];
                for (const v of q) {
                  try { window.plinkoSetBalance(v); } catch (err) { console.error('drain plinko queue', err); }
                }
              }
              if (pendingPlinkoPersistBalance !== null && session?.user?.id) {
                const queuedPersist = Number(pendingPlinkoPersistBalance);
                if (!isNaN(queuedPersist)) {
                  pendingPlinkoPersistBalance = null;
                  try { window.plinkoSetBalance(queuedPersist); } catch (err) { console.error('drain plinko persist queue', err); }
                }
              }
            } catch (err) { /* noop */ }
        })
        .catch((e) => console.error('Plinko build fetch failed', e));
    }
    if(window.plinkoResize){
      // allow layout to settle before measuring canvas
      requestAnimationFrame(()=>window.plinkoResize());
    }
  }
}
document.querySelectorAll(".navBtn[data-view]").forEach(b=>b.onclick=()=>setView(b.dataset.view));

async function ensureProfile(){
  const user=session?.user; if(!user) return;
  const email=(user.email||"").toLowerCase();
  const { data, error } = await supabase.from("profiles").select("*").eq("id", user.id).maybeSingle();
  if(error){ toast("Profile not loaded. Run SQL then Refresh."); console.error(error); return; }
  if(data){
    meProfile=data;
    try{ setHostBalance(Number(meProfile.pts||0)); }catch(e){}
    if (pendingPlinkoBalance !== null) {
      const queued = Number(pendingPlinkoBalance);
      pendingPlinkoBalance = null;
      try {
        if (!isNaN(queued)) {
          if (typeof window.plinkoSetBalance === 'function') {
            await window.plinkoSetBalance(queued);
          } else {
            setHostBalance(queued);
          }
        }
      } catch (_) {}
    }
    if (pendingPlinkoPersistBalance !== null && session?.user?.id && typeof window.plinkoSetBalance === 'function') {
      const queuedPersist = Number(pendingPlinkoPersistBalance);
      pendingPlinkoPersistBalance = null;
      try {
        if (!isNaN(queuedPersist)) {
          await window.plinkoSetBalance(queuedPersist);
        }
      } catch (_) {}
    }
    return;
  }
  const name = getAdminDisplayNameByEmail(email) || ((user.user_metadata?.display_name) || (email.split("@")[0]||"Player"));
  const curM=monthKey();
  const { data: ins, error: e2 } = await supabase.from("profiles").insert({
    id:user.id, email:user.email, display_name:name, pts:10.00, lifetime_wager:0, month_wager:0, month_key:curM, level:1
  }).select("*").single();
  if(e2){ toast("Profile create failed (DB/RLS)."); console.error(e2); return; }
  meProfile=ins;
  try{ setHostBalance(Number(meProfile.pts||0)); }catch(e){}
  if (pendingPlinkoBalance !== null) {
    const queued = Number(pendingPlinkoBalance);
    pendingPlinkoBalance = null;
    try {
      if (!isNaN(queued)) {
        if (typeof window.plinkoSetBalance === 'function') {
          await window.plinkoSetBalance(queued);
        } else {
          setHostBalance(queued);
        }
      }
    } catch (_) {}
  }
  if (pendingPlinkoPersistBalance !== null && session?.user?.id && typeof window.plinkoSetBalance === 'function') {
    const queuedPersist = Number(pendingPlinkoPersistBalance);
    pendingPlinkoPersistBalance = null;
    try {
      if (!isNaN(queuedPersist)) {
        await window.plinkoSetBalance(queuedPersist);
      }
    } catch (_) {}
  }
}

// Helps phones recover when the first fetch races session/init
async function ensureProfileReady(){
  if(meProfile || !session?.user) return;
  await ensureProfile();
  if(meProfile) return;
  // small backoff retry
  await new Promise(r=>setTimeout(r, 250));
  await ensureProfile();
}

async function normalizeMonthForMe(){
  if(!meProfile) return;
  const cur=monthKey();
  const currentKey = String(meProfile.month_key || "").trim() || cur;
  if(currentKey !== cur){
    await supabase.from("profiles").update({ month_key:cur, month_wager:0 }).eq("id", meProfile.id);
    meProfile.month_key=cur; meProfile.month_wager=0;
  }
}

async function maybeRollMonth(){
  const cur = monthKey();
  const { data: st, error } = await supabase.from("app_state").select("*").eq("id", 1).maybeSingle();
  if(error || !st) return;

  const stored = st.current_month || cur;
  if(stored === cur) return;

  const prev = stored;

  const { data: leaders, error: e2 } = await supabase
    .from("profiles")
    .select("id,pts,month_wager")
    .eq("month_key", prev)
    .order("month_wager",{ascending:false})
    .limit(1);

  if(!e2 && leaders && leaders.length){
    const w = leaders[0];
    await supabase.from("profiles").update({ pts: clamp2(Number(w.pts||0)+3) }).eq("id", w.id);
  }

  await supabase.from("profiles").update({ month_wager: 0, month_key: cur });

  await supabase.from("app_state").update({
    current_month: cur,
    last_awarded_month: prev,
    updated_at: new Date().toISOString()
  }).eq("id", 1);
}

async function loadMyBets(){
  const uid=session?.user?.id; if(!uid) return;
  const r = await supabase.from("bets")
    .select("id,created_at,event_name,opt_name,stake,coef,status,payout,event_id,option_id")
    .eq("user_id", uid)
    .order("created_at",{ascending:false})
    .limit(120);

  if(r.error){
    console.error(r.error);
    $("myBetsBody").innerHTML = `<tr><td colspan="7" class="muted">Cannot load bets (DB/RLS).</td></tr>`;
    return;
  }

  myBets = r.data || [];
  $("chipMyBets").textContent=String(myBets.length);
  $("myBetsCount").textContent=String(myBets.length);

  $("myBetsBody").innerHTML = myBets.length ? myBets.map(b=>`
    <tr>
      <td class="mono">${new Date(b.created_at).toLocaleString([], {month:"2-digit", day:"2-digit", hour:"2-digit", minute:"2-digit"})}</td>
      <td>${esc(b.event_name||"")}</td>
      <td>${esc(b.opt_name||"")}</td>
      <td class="mono">${to2(b.stake||0)}</td>
      <td class="mono">${to2(b.coef||0)}</td>
      <td><span class="tag ${String(b.status||"pending")==="pending"?"pending":(String(b.status)==="won"?"open":"settled")}">${String(b.status||"pending").toUpperCase()}</span></td>
      <td class="mono">${Number(b.payout||0)>0 ? to2(b.payout) : "—"}</td>
    </tr>`).join("") : `<tr><td colspan="7" class="muted">No bets yet.</td></tr>`;
}

async function loadEventOptionsFor(ids){
  if(!ids.length) return new Map();
  const { data, error } = await supabase
    .from("event_options")
    .select("id,event_id,label,coef")
    .in("event_id", ids)
    .order("id", { ascending: true });

  if(error) throw error;
  const map = new Map();
  for(const row of (data||[])){
    if(!map.has(row.event_id)) map.set(row.event_id, []);
    map.get(row.event_id).push({
      id: row.id,
      name: row.label,
      coef: Number(row.coef)
    });
  }
  return map;
}

async function loadEvents(){
  const { data, error } = await supabase
    .from("events")
    .select("id,name,description,status,created_at,created_by,winner_option_id")
    .order("created_at",{ascending:false});

  if(error){ toast("Events load failed (DB/RLS)."); console.error(error); return; }

  const base = data || [];
  const ids = base.map(e=>e.id);

  try{
    const optMap = await loadEventOptionsFor(ids);
    events = base.map(ev => ({ ...ev, options: optMap.get(ev.id) || [] }));
  }catch(e){
    console.error(e);
    events = base.map(ev => ({ ...ev, options: [] }));
  }

  $("chipEvents").textContent=String(events.length);
  $("chipSports").textContent=String(events.length);
  $("chipSports2").textContent=String(events.length);
  $("sportsCountHome").textContent=String(Math.min(6, events.length));
  renderSports();
}

async function addWagerAndPayout(stake, payout){
  if(!(await ensureActionReady(false))) throw new Error("session");
  if(!meProfile) throw new Error("profile");
  await normalizeMonthForMe();
  stake = Number(stake);
  payout = Number(payout);
  if(!(stake>0)) throw new Error("stake");
  if(Number(meProfile.pts) < stake) throw new Error("balance");
  const newPts = clamp2(Number(meProfile.pts) - stake + payout);
  const newLife = clamp2(Number(meProfile.lifetime_wager||0) + stake);
  const newMonth = clamp2(Number(meProfile.month_wager||0) + stake);
  const newLvl = computeLevel(newLife);
  const { error } = await supabase.from("profiles").update({
    pts:newPts, lifetime_wager:newLife, month_wager:newMonth, month_key:monthKey(), level:newLvl
  }).eq("id", session.user.id);
  if(error) throw error;
  // Update host balance only after DB confirmed
  meProfile.lifetime_wager=newLife; meProfile.month_wager=newMonth; meProfile.level=newLvl;
  setHostBalance(newPts);
  refreshCaseUI();
  return { newPts, newLvl };
}

function renderSports(){
  const mkTile = (icon, title, desc, tagCls, tagTxt, meta)=>`
    <div class="tileArt"><span>${icon}</span></div>
    <div class="tileBody">
      <p class="tileTitle">${esc(title)}</p>
      <div class="tileDesc">${desc?esc(desc):'<span class="muted">No description</span>'}</div>
      <div class="tileMeta"><span class="tag ${tagCls}">${tagTxt}</span><span class="oddsMini">${esc(meta||"")}</span></div>
    </div>`;

  const grid=$("eventsGrid"); grid.innerHTML="";
  const gridH=$("sportsGridHome"); gridH.innerHTML="";

  if(!events.length){
    grid.innerHTML='<div class="muted">No events yet (Admin creates them).</div>';
    gridH.innerHTML='<div class="muted">No events yet.</div>';
    return;
  }

  events.forEach((ev, idx)=>{
    const tagCls = ev.status==="open" ? "open" : (ev.status==="closed" ? "closed" : "settled");
    const opts = Array.isArray(ev.options)?ev.options:[];
    const mini = opts.length
      ? (opts.slice(0,2).map(o=>`${o.name} ${to2(o.coef)}`).join(" • ") + (opts.length>2?" • …":""))
      : "Tap to bet";

    const el=document.createElement("div"); el.className="tile";
    el.innerHTML = mkTile("🏟️", ev.name||"Event", ev.description||"", tagCls, String(ev.status||"open").toUpperCase(), mini);
    el.onclick=()=>openEventModal(ev);
    grid.appendChild(el);

    if(idx<6){
      const el2=document.createElement("div"); el2.className="tile";
      el2.innerHTML = mkTile("⚔️", ev.name||"Event", ev.description||"", tagCls, String(ev.status||"open").toUpperCase(), mini);
      el2.onclick=()=>openEventModal(ev);
      gridH.appendChild(el2);
    }
  });
}

function renderGames(){
  const G=[
    {icon:"🎲",name:"Dice",desc:"Quick roll"},
    {icon:"💣",name:"Mines",desc:"Pick safe tiles"},
    {icon:"🪙",name:"Plinko",desc:"Drop & win"},
    {icon:"🚀",name:"Crash",desc:"Cash out"},
    {icon:"🃏",name:"Blackjack",desc:"Classic 21"},
    {icon:"🎰",name:"Slots",desc:"Spin reels"},
    {icon:"🎯",name:"Keno",desc:"Pick numbers"},
    {icon:"🎡",name:"Roulette",desc:"Red / black"},
  ];
  const mk=(g)=>{
    const el=document.createElement("div"); el.className="tile";
    el.innerHTML = `
      <div class="tileArt"><span>${g.icon}</span></div>
      <div class="tileBody">
        <p class="tileTitle">${esc(g.name)}</p>
        <div class="tileDesc">${esc(g.desc)}</div>
        <div class="tileMeta"><span class="tag">GAME</span><span class="oddsMini">Live/soon</span></div>
      </div>`;
    el.onclick=()=>{
      if(g.name==="Dice") setView("dice");
      else if(g.name==="Roulette") setView("roulette");
      else if(g.name==="Mines") setView("mines");
      else if(g.name==="Blackjack") setView("blackjack");
      else if(g.name==="Plinko") setView("plinko");
      else toast("Coming soon");
    };
    return el;
  };
  $("gamesGrid").innerHTML=""; $("gamesGridHome").innerHTML="";
  G.forEach(g=>{ $("gamesGrid").appendChild(mk(g)); $("gamesGridHome").appendChild(mk(g)); });
  $("chipGames").textContent=String(G.length);
}

/* EVENT MODAL + CONFIRM */
let currentEvent=null;
let selectedOpt=null;

function openEventModal(ev){
  if(!meProfile){ toast("Profile not loaded (Refresh)."); return; }
  currentEvent=ev; selectedOpt=null;
  $("mConfirm").disabled=true;
  $("mTitle").textContent=ev.name||"Event";
  $("mDesc").textContent=ev.description||"";
  const st=String(ev.status||"open");
  $("mStatus").textContent=st.toUpperCase();
  $("mStatus").className="tag " + (st==="open"?"open":(st==="closed"?"closed":"settled"));
  $("mBal").textContent=to2(meProfile.pts||0);
  $("mStake").value = to2(Number($("defaultStake").value)||0.10);
  renderOdds(ev);
  updatePotential();
  $("overlay").classList.add("show");
}
function closeEventModal(){ $("overlay").classList.remove("show"); currentEvent=null; selectedOpt=null; $("mConfirm").disabled=true; }
$("closeModal").onclick=closeEventModal;
$("mCancel").onclick=closeEventModal;
$("overlay").onclick=(e)=>{ if(e.target===$("overlay")) closeEventModal(); };

function updatePotential(){
  const stake=Number($("mStake").value);
  if(!(stake>0) || !selectedOpt){ $("mPayout").textContent="—"; $("mConfirm").disabled=true; return; }
  $("mPayout").textContent = to2(stake * Number(selectedOpt.coef));
  $("mConfirm").disabled = false;
}
$("mStake").addEventListener("input", updatePotential);

function renderOdds(ev){
  const box=$("mOdds"); box.innerHTML="";
  const opts=Array.isArray(ev.options)?ev.options:[];
  if(!opts.length){
    box.innerHTML = `<div class="muted">No options found for this event.</div>`;
    return;
  }
  const coefs = opts.map(o=>Number(o.coef));
  const minC = Math.min(...coefs);
  const maxC = Math.max(...coefs);

  opts.forEach((o)=>{
    let cls="";
    if(minC !== maxC){
      if(Number(o.coef) === maxC) cls="g";
      else if(Number(o.coef) === minC) cls="r";
    }
    const btn=document.createElement("div");
    btn.className="oddBtn "+cls;
    btn.innerHTML=`<div class="oddName">${esc(o.name)}</div><div class="oddCoef">${to2(o.coef)}</div>`;
    btn.onclick=()=>{
      selectedOpt=o;
      [...box.querySelectorAll(".oddBtn")].forEach(x=>x.classList.remove("selected"));
      btn.classList.add("selected");
      sfx(660,0.05,"triangle",0.03);
      updatePotential();
    };
    box.appendChild(btn);
  });
}

$("mConfirm").onclick = async ()=>{
  if(!currentEvent || !selectedOpt) return;
  const stake=Number($("mStake").value);
  toast(`Confirming ${to2(stake)} on ${selectedOpt.name}…`);
  await placeBet(currentEvent, selectedOpt);
};

async function placeBet(ev,opt){
  if(!(await ensureActionReady())) return;
  if(String(ev.status)!=="open") return toast("Event not open");
  if(!meProfile) return toast("Profile not loaded");
  await normalizeMonthForMe();

  const stake=Number($("mStake").value);
  if(!(stake>0)) return toast("Stake must be > 0");
  if(stake<0.01) return toast("Min 0.01");
  if(Number(meProfile.pts)<stake) return toast("Not enough points");

  const chk = await supabase.from("bets").select("id").eq("user_id", session.user.id).eq("event_id", ev.id).limit(1);
  if(!chk.error && chk.data && chk.data.length) return toast("Already bet this event");

  const newPts=clamp2(Number(meProfile.pts) - stake + (opt.coef * stake));
  const newLife = clamp2(Number(meProfile.lifetime_wager||0) + stake);
  const newMonth = clamp2(Number(meProfile.month_wager||0) + stake);
  const newLvl = computeLevel(newLife);

  const u1 = await supabase.from("profiles").update({
    pts:newPts, lifetime_wager:newLife, month_wager:newMonth, month_key:monthKey(), level:newLvl
  }).eq("id", session.user.id);
  if(u1.error){ toast("Bet failed (DB/RLS)."); console.error(u1.error); return; }

  const ins = await supabase.from("bets").insert({
    user_id: session.user.id,
    event_id: ev.id,
    option_id: opt.id,
    event_name: ev.name,
    opt_name: opt.name,
    stake: Number(to2(stake)),
    coef: Number(to2(opt.coef)),
    status: "pending",
    payout: 0
  });
  if(ins.error){ toast("Bet insert failed (DB/RLS)."); console.error(ins.error); return; }

  meProfile.lifetime_wager=newLife; meProfile.month_wager=newMonth; meProfile.level=newLvl;
  setHostBalance(newPts);
  await loadMyBets();
  toast("Bet placed");
  closeEventModal();
}

/* PROFILE MODAL */
function openProfile(){
  if(!meProfile) return toast("Profile not loaded");
  $("pUserEdit").value = meProfile.display_name||"";
  applyAvatar($("pAvatar"), meProfile.avatar_seed||"p1");
  window.__selectedAvatar = meProfile.avatar_seed||"p1";
  $("pBal").textContent = to2(meProfile.pts||0);
  $("pLevel").textContent = String(meProfile.level||1);
  $("pMonthW").textContent = to2(meProfile.month_wager||0);
  $("pLifeW").textContent = to2(meProfile.lifetime_wager||0);
  $("pBets").textContent = String(myBets.length);
  $("profileOverlay").classList.add("show");
}
function closeProfile(){ $("profileOverlay").classList.remove("show"); }
$("profileBtn").onclick=openProfile;
$("closeProfile").onclick=closeProfile;
$("pCloseBtn").onclick=closeProfile;

document.querySelectorAll('[data-ava]').forEach(btn=>{
  btn.onclick=()=>{
    window.__selectedAvatar = btn.getAttribute("data-ava");
    applyAvatar($("pAvatar"), window.__selectedAvatar);
    toast("Avatar selected");
  };
});
$("pSaveBtn").onclick=async ()=>{
  if(!meProfile) return toast("Profile not loaded");
  const newName = $("pUserEdit").value.trim();
  if(!newName) return toast("Username required");
  const seed = window.__selectedAvatar || (meProfile.avatar_seed||"p1");
  const { error } = await supabase.from("profiles").update({ display_name:newName, avatar_seed:seed }).eq("id", session.user.id);
  if(error){ toast("Save failed (DB/RLS)."); console.error(error); return; }
  meProfile.display_name=newName; meProfile.avatar_seed=seed;
  updateMeUI();
  toast("Profile updated");
};
$("profileOverlay").onclick=(e)=>{ if(e.target===$("profileOverlay")) closeProfile(); };

/* LEADERBOARD */
async function refreshLeaderboard(){
  const cur=monthKey();
  $("lbMonth").textContent=cur;
  const { data: monthRows, error: monthErr } = await supabase.from("profiles").select("id,display_name,month_wager,level,month_key").eq("month_key", cur).order("month_wager",{ascending:false}).limit(50);
  if(monthErr){
    $("lbBody").innerHTML = `<tr><td colspan="4" class="muted">Leaderboard failed (DB/RLS).</td></tr>`;
    console.error(monthErr);
  }else{
    const rows=monthRows||[];
    $("chipLb").textContent=String(rows.length);
    $("lbCountMonth").textContent=String(rows.length);
    $("lbBody").innerHTML = rows.length ? rows.map((r,i)=>{
      const rank=i+1;
      const topClass = rank<=3 ? `top${rank}` : "";
      const medal = rank<=3 ? `<span class="medal m${rank}">${rank}</span>` : `<span class="mono">${rank}</span>`;
      return `
      <tr class="${topClass}">
        <td><div class="lbRank">${medal}</div></td>
        <td>${esc(r.display_name||"Player")}</td>
        <td class="mono">${to2(r.month_wager||0)}</td>
        <td class="mono">Lv ${Number(r.level||1)}</td>
      </tr>`;
    }).join("") : `<tr><td colspan="4" class="muted">No data yet. Place some bets first.</td></tr>`;
  }

  // Last 24h leaderboard (approx): sum stakes of bets in past 24h
  const since = new Date(Date.now() - 24*60*60*1000).toISOString();
  const { data: bets24, error: betsErr } = await supabase
    .from("bets")
    .select("user_id, stake, created_at")
    .gte("created_at", since)
    .limit(5000);

  if(betsErr){
    $("lbBodyDay").innerHTML = `<tr><td colspan="4" class="muted">24h board failed.</td></tr>`;
    console.error(betsErr);
    return;
  }

  const totals=new Map();
  (bets24||[]).forEach(b=>{
    const uid=b.user_id; if(!uid) return;
    const prev=totals.get(uid)||0;
    totals.set(uid, prev + Number(b.stake||0));
  });

  // Map user info
  const { data: profs, error: profErr } = await supabase.from("profiles").select("id, display_name, level");
  if(profErr){
    $("lbBodyDay").innerHTML = `<tr><td colspan="4" class="muted">24h profiles failed.</td></tr>`;
    console.error(profErr);
    return;
  }
  const profMap=new Map((profs||[]).map(p=>[p.id, p]));

  const dayRows = Array.from(totals.entries())
    .map(([uid, amt])=>({ uid, amt }))
    .sort((a,b)=>b.amt - a.amt)
    .slice(0,50);

  $("lbCountDay").textContent = String(dayRows.length);
  $("lbBodyDay").innerHTML = dayRows.length ? dayRows.map((r,i)=>{
    const prof=profMap.get(r.uid)||{};
    return `
      <tr>
        <td class="mono">${i+1}</td>
        <td>${esc(prof.display_name||"Player")}</td>
        <td class="mono">${to2(r.amt||0)}</td>
        <td class="mono">Lv ${Number(prof.level||1)}</td>
      </tr>`;
  }).join("") : `<tr><td colspan="4" class="muted">No 24h wagers yet.</td></tr>`;
}

/* DAILY CASE + COUNTDOWN */
const CASE_ITEMS=[
  {label:"100", amount:100, skin:"Common Pull", variant:"Daily Blue", tone:"toneBlue", iconType:"yellow", p:70},
  {label:"250", amount:250, skin:"Rare Pull", variant:"Daily Violet", tone:"tonePurple", iconType:"yellow", p:10},
  {label:"500", amount:500, skin:"Epic Pull", variant:"Daily Violet", tone:"tonePurple", iconType:"yellow", p:7.5},
  {label:"1000", amount:1000, skin:"Mythic Pull", variant:"Daily Violet", tone:"tonePurple", iconType:"yellow", p:2.5},
  {label:"0.00", amount:0.00, skin:"Miss", variant:"Unlucky", tone:"toneSilver", iconType:"poop", p:9},
  {label:"10000", amount:10000, skin:"Legend Pull", variant:"Golden Ultra", tone:"toneGold", iconType:"blue", p:1},
];
function caseIcon(iconType){
  if(iconType==="blue") return `<span class="skinIcon glow">${gemBlue()}</span>`;
  if(iconType==="yellow") return `<span class="skinIcon glow">${gemYellow()}</span>`;
  return `<span class="skinIcon">${poop()}</span>`;
}
function caseDropIcon(iconType){
  if(iconType==="blue") return `<span class="glow">${gemBlue()}</span>`;
  if(iconType==="yellow") return `<span class="glow">${gemYellow()}</span>`;
  return `${poop()}`;
}
function showCaseDropPopup(item){
  const overlay=$("caseDropOverlay");
  const card=$("caseDropItem");
  const title=$("caseDropTitle");
  if(!overlay || !card || !title || !item) return;
  clearTimeout(overlay._closeTimer);
  overlay.classList.remove("closing");
  title.textContent = Number(item.amount)>0 ? "You won" : "No reward";
  card.className = `caseDropItem ${item.tone||"toneBlue"}`;
  card.innerHTML = `
    <div class="dropArt">${caseDropIcon(item.iconType)}</div>
    <div class="dropMeta">
      <div class="dropName">${esc(item.skin||"Drop")}</div>
      <div class="dropVariant">${esc(item.variant||"Item")}</div>
      <div class="dropValue ${Number(item.amount)<=0?"dropMiss":""}">${to2(item.amount||0)}</div>
    </div>
  `;
  overlay.classList.add("show");
}
function hideCaseDropPopup(){
  const overlay=$("caseDropOverlay");
  if(!overlay || !overlay.classList.contains("show")) return;
  overlay.classList.remove("show");
  overlay.classList.add("closing");
  clearTimeout(overlay._closeTimer);
  overlay._closeTimer = setTimeout(()=>{
    overlay.classList.remove("closing");
  }, 210);
}
$("caseDropClose")?.addEventListener("click", hideCaseDropPopup);
$("caseDropOverlay")?.addEventListener("click", (ev)=>{
  if(ev.target && ev.target.id==="caseDropOverlay") hideCaseDropPopup();
});
document.addEventListener("keydown", (ev)=>{
  if(ev.key==="Escape") hideCaseDropPopup();
});
function weightedPick(){
  const r=Math.random()*100; let a=0;
  for(const it of CASE_ITEMS){ a+=it.p; if(r<=a) return it; }
  return CASE_ITEMS[0];
}
function caseEligible(){
  if(!meProfile) return {ok:false, reason:"Profile not loaded"};
  const cur=monthKey();
  const myMonth = ((meProfile.month_key||cur)===cur) ? Number(meProfile.month_wager||0) : 0;
  const hasReq = myMonth>=10;
  const already = String(meProfile.last_case_open||"")===todayISO();
  if(!hasReq && !isAdmin) return {ok:false, reason:"Need 10 wager", myMonth};
  if(already && !isAdmin) return {ok:false, reason:"Already opened today", myMonth};
  return {ok:true, myMonth};
}
function buildCaseStrip(target){
  const arr=[];
  const pre=56, post=24;
  for(let i=0;i<pre;i++) arr.push({ ...CASE_ITEMS[Math.floor(Math.random()*CASE_ITEMS.length)] });
  arr.push({ ...target, __win:true });
  for(let i=0;i<post;i++) arr.push({ ...CASE_ITEMS[Math.floor(Math.random()*CASE_ITEMS.length)] });
  return arr;
}

function renderCaseTrack(items){
  const track=$("caseTrack"); track.innerHTML="";
  items.forEach(it=>{
    const el=document.createElement("div"); el.className=`caseItem ${it.tone||"toneBlue"}`;
    el.innerHTML = `
      <div class="skinArt">${caseIcon(it.iconType)}</div>
      <div class="skinMeta">
        <div class="skinName">${it.skin||"Skin"}</div>
        <div class="skinVariant">${it.variant||"Pattern"}</div>
      </div>
      <div class="skinValue">${it.label}</div>
    `;
    track.appendChild(el);
  });
}
function getTranslateX(el){
  const tr=getComputedStyle(el).transform;
  if(!tr || tr==="none") return 0;
  if(tr.startsWith("matrix3d(")){
    const parts=tr.slice(9,-1).split(",").map(Number);
    return Number(parts[12]||0);
  }
  if(tr.startsWith("matrix(")){
    const parts=tr.slice(7,-1).split(",").map(Number);
    return Number(parts[4]||0);
  }
  return 0;
}
function animateCaseTrackDecel(track, targetX, durationMs){
  const startX=getTranslateX(track);
  const delta=targetX-startX;
  const start=performance.now();
  const easeOut=(t)=>1-Math.pow(1-t,2.05);
  const step=(now)=>{
    const p=Math.min(1,(now-start)/durationMs);
    const e=easeOut(p);
    const x=startX+(delta*e);
    track.style.transform=`translateY(-50%) translateX(${x}px)`;
    if(p<1) requestAnimationFrame(step);
  };
  requestAnimationFrame(step);
}

function refreshCaseUI(){
  if(!meProfile){ $("caseStatus").textContent="PROFILE NOT LOADED"; $("openCaseBtn").disabled=true; return; }
  const cur=monthKey();
  const myMonth = ((meProfile.month_key||cur)===cur) ? Number(meProfile.month_wager||0) : 0;
  $("caseReq").textContent = `${to2(myMonth)} / 10.00`;
  const e=caseEligible();
  $("caseStatus").textContent = e.ok ? "READY" : (isAdmin ? "ADMIN" : e.reason.toUpperCase());
  $("openCaseBtn").disabled = !e.ok && !isAdmin;
  $("openCaseBtn").style.opacity = (!e.ok && !isAdmin) ? "0.6" : "1";
}
function updateCaseCountdown(){
  const now = new Date();
  const next = new Date(now);
  next.setHours(24,0,0,0);
  const ms = Math.max(0, next - now);
  const h = Math.floor(ms/3600000);
  const m = Math.floor((ms%3600000)/60000);
  const s = Math.floor((ms%60000)/1000);
  $("caseCountdown").textContent = `${String(h).padStart(2,"0")}:${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
}
setInterval(updateCaseCountdown, 1000);
updateCaseCountdown();

let caseSpinning=false;
$("openCaseBtn").onclick=async ()=>{
  if(!(await ensureActionReady())) return;
  if(caseSpinning) return;
  if(!meProfile) return toast("Profile not loaded");
  const elig=caseEligible();
  if(!elig.ok && !isAdmin) return toast("Daily case locked (wager 10)");
  caseSpinning=true;
  const reward=weightedPick();
  const strip=buildCaseStrip(reward);
  renderCaseTrack(strip);

  const track=$("caseTrack");
  track.style.transition="none";
  track.style.transform="translateY(-50%) translateX(0px)";
  const stage=track.parentElement;
  const firstCard=track.firstElementChild;
  const itemW=firstCard ? firstCard.getBoundingClientRect().width : 120;
  const computed=getComputedStyle(track);
  const gap=parseFloat(computed.columnGap || computed.gap || "14") || 14;
  const sidePad=parseFloat(computed.paddingLeft || "20") || 20;
  const stageW=stage.clientWidth;
  const winIndex = Math.max(0, strip.findIndex((it)=>it.__win));
  const randomOffset = (itemW * (0.16 + Math.random()*0.68)) + ((Math.random()-0.5) * gap * 0.55);
  const winPoint = sidePad + winIndex*(itemW+gap) + randomOffset;
  const targetX=(stageW/2)-winPoint;
  const spinDurationMs = 6000;
  const settleAfterMs = spinDurationMs + 140;

  animateCaseTrackDecel(track, targetX, spinDurationMs);

  const step = itemW + gap;
  let lastSlot = null;
  const tm=setInterval(()=>{
    const tx=getTranslateX(track);
    const pointerX=(stageW/2)-tx;
    const slot=Math.floor((pointerX-sidePad)/step);
    if(slot!==lastSlot){
      sfx(900,0.015,"square",0.05);
      lastSlot=slot;
    }
  }, 22);

  setTimeout(async ()=>{
    clearInterval(tm);
    const prize=Number(reward.amount);
    const today=todayISO();
    const newPts=clamp2(Number(meProfile.pts)+prize);
    const { error } = await supabase.from("profiles").update({ pts:newPts, last_case_open: today }).eq("id", session.user.id);
    if(error){ toast("Case payout failed (DB/RLS)."); console.error(error); caseSpinning=false; return; }
    meProfile.last_case_open=today;
    setHostBalance(newPts);
    refreshCaseUI();
    showCaseDropPopup(reward);
    toast(prize>0 ? `You won ${to2(prize)}` : "You won 0.00");
    caseSpinning=false;
  }, settleAfterMs);
};
renderCaseTrack(buildCaseStrip(CASE_ITEMS[0]));

/* ADMIN: USERS */
async function loadUsersList(){
  if(!isAdmin) return;
  let data = [];
  const primary = await supabase
    .from("profiles")
    .select("id,display_name,email,pts,last_seen")
    .order("created_at",{ascending:true})
    .limit(200);

  if(primary.error){
    const msg = String(primary.error.message||"");
    if(/last_seen/i.test(msg)){
      const fallback = await supabase
        .from("profiles")
        .select("id,display_name,email,pts")
        .order("created_at",{ascending:true})
        .limit(200);
      if(fallback.error){
        $("adminUserHint").textContent="Cannot load users. Run SQL then Refresh. Users must sign in once to create a profile.";
        console.error(fallback.error);
        return;
      }
      data = (fallback.data||[]).map(u=>({ ...u, last_seen:null }));
    } else {
      $("adminUserHint").textContent="Cannot load users. Run SQL then Refresh. Users must sign in once to create a profile.";
      console.error(primary.error);
      return;
    }
  } else {
    data = primary.data || [];
  }

  usersList=data||[];
  const sel=$("userSelect");
  sel.innerHTML = usersList.length ? usersList.map(u=>`<option value="${u.id}">${esc(u.display_name||"User")} — ${esc(u.email||"")}</option>`).join("") : `<option value="">No users</option>`;
  $("adminUserHint").textContent = usersList.length ? `${usersList.length} users loaded` : "No users yet.";
}

function isOnlineNow(lastSeen){
  if(!lastSeen) return false;
  const ts = new Date(lastSeen).getTime();
  if(!Number.isFinite(ts)) return false;
  return (Date.now() - ts) <= 120000;
}

function fmtLastSeen(lastSeen){
  if(!lastSeen) return "—";
  const d = new Date(lastSeen);
  if(Number.isNaN(d.getTime())) return "—";
  return d.toLocaleString([], { month:"2-digit", day:"2-digit", hour:"2-digit", minute:"2-digit", second:"2-digit" });
}

async function loadLatestBetActivityMap(){
  const map = new Map();
  const { data, error } = await supabase
    .from("bets")
    .select("user_id,created_at")
    .order("created_at", { ascending:false })
    .limit(5000);
  if(error){
    console.error(error);
    return map;
  }
  for(const row of (data||[])){
    const uid = row.user_id;
    const at = row.created_at;
    if(!uid || !at) continue;
    if(!map.has(uid)) map.set(uid, at);
  }
  return map;
}

async function loadAdminPlayers(){
  if(!isAdmin) return;
  if(adminPlayersLoading){
    adminPlayersPending = true;
    return;
  }
  adminPlayersLoading = true;
  const body = $("adminPlayersBody");
  if(!body){
    adminPlayersLoading = false;
    return;
  }

  try{
    let rows = [];
    let hasLastSeen = true;
    let fallbackActivityMap = new Map();

    const withSeen = await supabase
      .from("profiles")
      .select("id,display_name,email,pts,last_seen,created_at")
      .order("created_at", { ascending:false })
      .limit(500);

    if(withSeen.error){
      const msg = String(withSeen.error.message||"");
      if(/last_seen/i.test(msg)){
        hasLastSeen = false;
        const fallback = await supabase
          .from("profiles")
          .select("id,display_name,email,pts,created_at")
          .order("created_at", { ascending:false })
          .limit(500);
        if(fallback.error){
          console.error(fallback.error);
          $("adminPlayersCount").textContent = "0";
          body.innerHTML = `<tr><td colspan="5" class="muted">Cannot load players. Check RLS/SQL permissions.</td></tr>`;
          return;
        }
        fallbackActivityMap = await loadLatestBetActivityMap();
        rows = (fallback.data || []).map((p)=>({ ...p, last_seen: null }));
      }else{
        console.error(withSeen.error);
        $("adminPlayersCount").textContent = "0";
        body.innerHTML = `<tr><td colspan="5" class="muted">Cannot load players. Check RLS/SQL permissions.</td></tr>`;
        return;
      }
    }else{
      rows = withSeen.data || [];
    }

    $("adminPlayersCount").textContent = String(rows.length);

    adminPlayersCache = rows.map((p)=>{
      const ptsNow = Number(p.pts || 0);
      const prevPts = adminBalanceSnapshotMap.get(p.id);
      if(prevPts !== undefined && Math.abs(Number(prevPts) - ptsNow) > 0.0001){
        markAdminSeen(p.id, new Date().toISOString());
      }
      adminBalanceSnapshotMap.set(p.id, ptsNow);

      const isMe =
        p.id === session?.user?.id ||
        (String(p.email||"").toLowerCase() && String(p.email||"").toLowerCase() === String(session?.user?.email||"").toLowerCase());
      const signalOnline = liveSignalOnlineSet.has(String(p.id));
      const presenceOnline = livePresenceOnlineSet.has(String(p.id));
      const realtimeSeen = adminRealtimeSeenMap.get(p.id) || null;
      const effectiveSeen = hasLastSeen
        ? (isMe ? new Date().toISOString() : (realtimeSeen || p.last_seen))
        : (isMe ? new Date().toISOString() : (realtimeSeen || fallbackActivityMap.get(p.id) || null));
      const online = isMe ? true : (signalOnline || presenceOnline || isOnlineNow(effectiveSeen));
      const statusText = online ? "ONLINE" : "OFFLINE";
      const statusClass = online ? "open" : "closed";
      const seenText = hasLastSeen
        ? (online ? "Now" : (isMe ? "Now" : fmtLastSeen(effectiveSeen)))
        : (online ? "Now" : (effectiveSeen ? fmtLastSeen(effectiveSeen) : "—"));
      const email = String(p.email||"");
      const emailLc = email.toLowerCase();
      const name = String(p.display_name||"Player");
      const lastSeenTs = new Date(effectiveSeen || 0).getTime();
      const createdTs = new Date(p.created_at || 0).getTime();
      const isNew = Number.isFinite(createdTs) ? ((Date.now() - createdTs) <= 24*60*60*1000) : false;
      return {
        id: p.id,
        name,
        nameLc: name.toLowerCase(),
        email,
        emailLc,
        pts: Number(p.pts||0),
        isNew,
        online,
        statusText,
        statusClass,
        seenText,
        lastSeenTs: Number.isFinite(lastSeenTs) ? lastSeenTs : 0,
      };
    });

    renderAdminPlayersTable();

    if(!hasLastSeen && rows.length){
      $("adminUserHint").textContent = `Loaded ${rows.length} players. Add last_seen column for exact online timestamps.`;
    }
    updateAdminPlayersSyncStamp();
  } finally {
    adminPlayersLoading = false;
    if(adminPlayersPending){
      adminPlayersPending = false;
      loadAdminPlayers();
    }
  }
}

function startAdminPlayersRealtime(){
  if(!supabase || !isAdmin || adminProfilesChannel) return;
  adminProfilesChannel = supabase
    .channel("admin-profiles-live")
    .on("postgres_changes", { event:"*", schema:"public", table:"profiles" }, (payload)=>{
      try{
        const p = payload?.new || payload?.old;
        if(p) patchAdminPlayerRowFromProfile(p);
      }catch(_){ }
      loadUsersList();
      loadAdminPlayers();
    })
    .subscribe();
}

function stopAdminPlayersRealtime(){
  if(!supabase || !adminProfilesChannel) return;
  try{ supabase.removeChannel(adminProfilesChannel); }catch(_){ }
  adminProfilesChannel = null;
}

async function repairMonthlyWagerFromBets(){
  if(!isAdmin) return toast("Admin only");
  const btn = $("repairMonthWagerBtn");
  const prevText = btn ? btn.textContent : "";
  if(btn){
    btn.disabled = true;
    btn.textContent = "Repairing…";
  }
  try{
    const now = new Date();
    const start = new Date(now.getFullYear(), now.getMonth(), 1, 0, 0, 0, 0);
    const next = new Date(now.getFullYear(), now.getMonth()+1, 1, 0, 0, 0, 0);
    const startIso = start.toISOString();
    const nextIso = next.toISOString();
    const cur = monthKey(now);

    let bets = [];
    let amountCol = "";
    let betsErr = null;
    for(const candidate of ["stake","amt","amount"]){
      const res = await supabase
        .from("bets")
        .select(`user_id,${candidate},created_at`)
        .gte("created_at", startIso)
        .lt("created_at", nextIso)
        .limit(200000);
      if(!res.error){
        bets = res.data || [];
        amountCol = candidate;
        betsErr = null;
        break;
      }
      const em = String(res.error.message || "").toLowerCase();
      const missingColumn = em.includes("does not exist") && em.includes("column");
      if(missingColumn){
        betsErr = res.error;
        continue;
      }
      betsErr = res.error;
      break;
    }

    if(!amountCol){
      console.error(betsErr);
      const msg = String(betsErr?.message || "cannot read bets");
      toast(`Repair failed (${msg})`);
      $("adminUserHint").textContent = `Monthly wager repair failed: ${msg}`;
      return;
    }

    const sumByUser = new Map();
    for(const row of (bets||[])){
      const uid = String(row?.user_id || "");
      if(!uid) continue;
      const amt = Number(row?.[amountCol] || 0);
      if(!(amt > 0)) continue;
      sumByUser.set(uid, clamp2(Number(sumByUser.get(uid) || 0) + amt));
    }

    const { data: profiles, error: profErr } = await supabase
      .from("profiles")
      .select("id,month_wager,month_key")
      .limit(2000);

    if(profErr){
      console.error(profErr);
      toast("Repair failed (cannot read profiles)");
      return;
    }

    const toUpdate = [];
    for(const p of (profiles||[])){
      const id = String(p?.id || "");
      if(!id) continue;
      const target = clamp2(Number(sumByUser.get(id) || 0));
      const curVal = clamp2(Number(p?.month_wager || 0));
      const keyNow = String(p?.month_key || "");
      if(Math.abs(curVal - target) > 0.0001 || keyNow !== cur){
        toUpdate.push({ id, month_wager: target, month_key: cur });
      }
    }

    for(let i=0;i<toUpdate.length;i+=50){
      const chunk = toUpdate.slice(i, i+50);
      await Promise.all(chunk.map((row)=>
        supabase
          .from("profiles")
          .update({ month_wager: row.month_wager, month_key: row.month_key })
          .eq("id", row.id)
      ));
    }

    if(meProfile?.id){
      meProfile.month_key = cur;
      meProfile.month_wager = clamp2(Number(sumByUser.get(meProfile.id) || 0));
      updateMeUI();
      refreshCaseUI();
    }

    const changed = toUpdate.length;
    $("adminUserHint").textContent = `Monthly wager repair done. Updated ${changed} profile(s) using current-month bets.`;
    toast(`Monthly wager repaired: ${changed}`);
    await loadUsersList();
    await loadAdminPlayers();
  }catch(err){
    console.error(err);
    toast("Repair failed");
  }finally{
    if(btn){
      btn.disabled = false;
      btn.textContent = prevText || "Repair monthly wager";
    }
  }
}

async function resetAllLevels(){
  if(!isAdmin) return toast("Admin only");
  const ok = confirm("Reset level to 1 for all users?");
  if(!ok) return;

  const btn = $("resetAllLevelsBtn");
  const prevText = btn ? btn.textContent : "";
  if(btn){
    btn.disabled = true;
    btn.textContent = "Resetting…";
  }

  try{
    const { error } = await supabase
      .from("profiles")
      .update({ level: 1 })
      .not("id", "is", null);

    if(error){
      console.error(error);
      const msg = String(error.message || "reset failed");
      $("adminUserHint").textContent = `Level reset failed: ${msg}`;
      toast(`Level reset failed (${msg})`);
      return;
    }

    if(meProfile){
      meProfile.level = 1;
      updateMeUI();
    }

    $("adminUserHint").textContent = "All player levels were reset to 1.";
    toast("All levels reset to 1");
    await loadUsersList();
    await loadAdminPlayers();
    await refreshLeaderboard();
  }catch(err){
    console.error(err);
    toast("Level reset failed");
  }finally{
    if(btn){
      btn.disabled = false;
      btn.textContent = prevText || "Reset all levels";
    }
  }
}

async function resetAllStatsAndLeaderboard(){
  if(!isAdmin) return toast("Admin only");
  const ok = confirm("Reset everyone to balance 1000, level 1, lifetime/month wager 0, and clear bets leaderboard?");
  if(!ok) return;

  const btn = $("resetAllStatsBtn");
  const prevText = btn ? btn.textContent : "";
  if(btn){
    btn.disabled = true;
    btn.textContent = "Resetting…";
  }

  try{
    const cur = monthKey();
    const { error: profileErr } = await supabase
      .from("profiles")
      .update({
        pts: 1000,
        lifetime_wager: 0,
        month_wager: 0,
        month_key: cur,
        level: 1,
        last_case_open: null,
      })
      .not("id", "is", null);

    if(profileErr){
      console.error(profileErr);
      const msg = String(profileErr.message || "reset failed");
      $("adminUserHint").textContent = `Full reset failed: ${msg}`;
      toast(`Full reset failed (${msg})`);
      return;
    }

    const { error: betsErr } = await supabase
      .from("bets")
      .delete()
      .not("id", "is", null);

    if(meProfile){
      meProfile.pts = 1000;
      meProfile.lifetime_wager = 0;
      meProfile.month_wager = 0;
      meProfile.month_key = cur;
      meProfile.level = 1;
      meProfile.last_case_open = null;
      setHostBalance(1000);
      updateMeUI();
      refreshCaseUI();
    }

    if(betsErr){
      console.error(betsErr);
      const msg = String(betsErr.message || "cannot clear bets");
      $("adminUserHint").textContent = `Profiles reset done, but bets were not cleared: ${msg}`;
      toast("Reset done, but leaderboard history not fully cleared");
    }else{
      $("adminUserHint").textContent = "Full reset completed: balances/stats reset and bets cleared.";
      toast("Full reset completed");
    }

    await loadUsersList();
    await loadAdminPlayers();
    await refreshLeaderboard();
    await loadMyBets();
  }catch(err){
    console.error(err);
    toast("Full reset failed");
  }finally{
    if(btn){
      btn.disabled = false;
      btn.textContent = prevText || "Reset everything";
    }
  }
}

$("reloadAdminPlayersBtn").onclick = ()=>loadAdminPlayers();
$("resetAllStatsBtn").onclick = ()=>resetAllStatsAndLeaderboard();
$("repairMonthWagerBtn").onclick = ()=>repairMonthlyWagerFromBets();
$("resetAllLevelsBtn").onclick = ()=>resetAllLevels();
$("adminPlayersToggleBtn").onclick = ()=>{
  adminPlayersShowAll = !adminPlayersShowAll;
  renderAdminPlayersTable();
};
$("adminPlayersSearch")?.addEventListener("input", (ev)=>{
  adminPlayersSearchText = String(ev?.target?.value || "").trim().toLowerCase();
  adminPlayersShowAll = false;
  renderAdminPlayersTable();
});
function getSelectedUser(){
  const id=$("userSelect").value;
  return usersList.find(u=>u.id===id) || null;
}
$("setPtsBtn").onclick=async ()=>{
  if(!isAdmin) return toast("Admin only");
  const u=getSelectedUser(); if(!u) return toast("Select user");
  const pts=Number($("ptsSet").value); if(!(pts>=0)) return toast("Invalid pts");
  const { error } = await supabase.from("profiles").update({ pts: clamp2(pts) }).eq("id", u.id);
  if(error){ toast("Set failed (DB/RLS)."); console.error(error); return; }
  toast("Points set");
  await loadUsersList();
  await loadAdminPlayers();
};
$("addBtn").onclick=async ()=>{
  if(!isAdmin) return toast("Admin only");
  const u=getSelectedUser(); if(!u) return toast("Select user");
  const add=Number($("ptsAdd").value); if(!(add>0)) return toast("Invalid add");
  const newPts=clamp2(Number(u.pts||0)+add);
  const { error } = await supabase.from("profiles").update({ pts:newPts }).eq("id", u.id);
  if(error){ toast("Add failed (DB/RLS)."); console.error(error); return; }
  toast("Added");
  await loadUsersList();
  await loadAdminPlayers();
};
$("resetUserLevelBtn").onclick=async ()=>{
  if(!isAdmin) return toast("Admin only");
  const u=getSelectedUser();
  if(!u) return toast("Select user");
  if(!confirm(`Reset level to 1 for ${u.display_name || "this user"}?`)) return;

  const btn = $("resetUserLevelBtn");
  const prevText = btn ? btn.textContent : "";
  if(btn){
    btn.disabled = true;
    btn.textContent = "Resetting…";
  }
  try{
    const { error } = await supabase.from("profiles").update({ level: 1 }).eq("id", u.id);
    if(error){
      console.error(error);
      toast("Reset selected level failed (DB/RLS).");
      return;
    }
    if(String(session?.user?.id||"") === String(u.id||"") && meProfile){
      meProfile.level = 1;
      updateMeUI();
    }
    toast("Selected user level reset to 1");
    await loadUsersList();
    await loadAdminPlayers();
    await refreshLeaderboard();
  } finally {
    if(btn){
      btn.disabled = false;
      btn.textContent = prevText || "Reset selected level";
    }
  }
};

/* ADMIN: CREATE EVENT */
let opts=[
  { tmpId: crypto.randomUUID(), name:"Player A", coef:1.80 },
  { tmpId: crypto.randomUUID(), name:"Player B", coef:2.10 }
];
function renderOptRows(){
  const box=$("optsBox"); box.innerHTML="";
  opts.forEach(o=>{
    const row=document.createElement("div"); row.className="row"; row.style.marginBottom="10px";
    row.innerHTML=`
      <div style="flex:1;min-width:220px;"><label>Option name</label><input data-on="${o.tmpId}" value="${esc(o.name)}"/></div>
      <div style="width:200px;"><label>Coef</label><input data-oc="${o.tmpId}" type="number" min="1.01" step="0.01" value="${to2(o.coef)}"/></div>
      <div style="width:160px;"><label>&nbsp;</label><button class="btn red" data-od="${o.tmpId}" style="width:100%;">Remove</button></div>
    `;
    box.appendChild(row);
  });
  box.querySelectorAll("input[data-on]").forEach(inp=>inp.oninput=(e)=>{ const id=e.target.dataset.on; opts=opts.map(o=>o.tmpId===id?({...o,name:e.target.value}):o); });
  box.querySelectorAll("input[data-oc]").forEach(inp=>inp.oninput=(e)=>{ const id=e.target.dataset.oc; const v=Number(e.target.value); if(!(v>=1.01)) return; opts=opts.map(o=>o.tmpId===id?({...o,coef:Number(to2(v))}):o); });
  box.querySelectorAll("button[data-od]").forEach(btn=>btn.onclick=(e)=>{ const id=e.target.dataset.od; opts=opts.filter(o=>o.tmpId!==id); renderOptRows(); });
}
$("addOptBtn").onclick=()=>{ if(!isAdmin) return toast("Admin only"); opts.push({ tmpId:crypto.randomUUID(), name:"", coef:2.00 }); renderOptRows(); };
renderOptRows();

$("createEventBtn").onclick = async () => {
  if (!isAdmin) return toast("Admin only");

  const name = $("evName").value.trim();
  const desc = $("evDesc").value.trim();
  const status = ($("evStatus").value.trim() || "open");

  if (!name) return toast("Event name required");
  if (opts.length < 2) return toast("Need 2+ options");
  for (const o of opts) {
    if (!String(o.name || "").trim()) return toast("Option needs name");
    if (!(Number(o.coef) >= 1.01)) return toast("Coef ≥ 1.01");
  }

  const normalized = opts.map(o => ({ label: String(o.name).trim(), coef: Number(to2(o.coef)) }));

  try {
    const { data: ev, error: evErr } = await supabase
      .from("events")
      .insert({ name, description: desc, status, created_by: session.user.id })
      .select("id")
      .single();
    if (evErr) throw evErr;

    const rows = normalized.map(o => ({ event_id: ev.id, label: o.label, coef: o.coef }));
    const { error: optErr } = await supabase.from("event_options").insert(rows);
    if (optErr) throw optErr;

    $("evName").value = "";
    $("evDesc").value = "";
    $("evStatus").value = "open";
    opts = [
      { tmpId: crypto.randomUUID(), name: "Player A", coef: 1.80 },
      { tmpId: crypto.randomUUID(), name: "Player B", coef: 2.10 }
    ];
    renderOptRows();

    toast("Event created");
    await loadEvents();
    await loadAdminEvents();
    setView("sports");
  } catch (e) {
    toast("Create failed (DB/RLS).");
    console.error(e);
  }
};

/* ADMIN: MANAGE EVENTS (open/close/finish winner/delete + payout) */
$("reloadAdminEventsBtn").onclick = ()=>loadAdminEvents();

async function loadAdminEvents(){
  if(!isAdmin){ $("adminEventsList").textContent="Admin only."; return; }

  await loadEvents();

  const { data: allBets, error: eB } = await supabase
    .from("bets")
    .select("event_id,status")
    .limit(5000);
  const counts = new Map();
  if(!eB && allBets){
    for(const b of allBets){
      const k=b.event_id;
      if(!counts.has(k)) counts.set(k,{total:0,pending:0,won:0,lost:0});
      const c=counts.get(k);
      c.total++;
      const st=String(b.status||"pending");
      if(st==="pending") c.pending++;
      else if(st==="won") c.won++;
      else if(st==="lost") c.lost++;
    }
  }

  const list = $("adminEventsList");
  if(!events.length){
    list.innerHTML = `<div class="muted">No events.</div>`;
    return;
  }

  list.innerHTML = events.map(ev=>{
    const c = counts.get(ev.id) || {total:0,pending:0,won:0,lost:0};
    const opts = ev.options || [];
    const winnerSel = `
      <select data-win="${ev.id}" style="margin-top:6px;">
        <option value="">— select winner —</option>
        ${opts.map(o=>`<option value="${o.id}" ${Number(ev.winner_option_id||0)===Number(o.id)?"selected":""}>${esc(o.name)} (${to2(o.coef)})</option>`).join("")}
      </select>
    `;
    return `
      <div style="border:1px solid rgba(255,255,255,.10);background:rgba(0,0,0,.22);border-radius:16px;padding:12px;margin-bottom:10px;">
        <div style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:flex-start;">
          <div style="min-width:0;">
            <div style="font-weight:950;">${esc(ev.name)} <span class="chip">${esc(ev.status||"open")}</span></div>
            <div class="muted" style="font-size:12px;margin-top:4px;">${esc(ev.description||"")}</div>
            <div class="muted" style="font-size:12px;margin-top:6px;">
              Bets: <span class="mono">${c.total}</span> (pending <span class="mono">${c.pending}</span>, won <span class="mono">${c.won}</span>, lost <span class="mono">${c.lost}</span>)
            </div>
            <div style="margin-top:8px;">
              <label>Winner</label>
              ${winnerSel}
            </div>
          </div>

          <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end;">
            <button class="btn" data-open="${ev.id}">Set OPEN</button>
            <button class="btn" data-close="${ev.id}">Set CLOSED</button>
            <button class="btn purple" data-finish="${ev.id}">Finish + Payout</button>
            <button class="btn red" data-del="${ev.id}">Delete</button>
          </div>
        </div>
      </div>
    `;
  }).join("");

  list.querySelectorAll("button[data-open]").forEach(b=>b.onclick=async ()=>{
    const id=Number(b.dataset.open);
    const r=await supabase.from("events").update({ status:"open" }).eq("id", id);
    if(r.error){ toast("Failed"); console.error(r.error); return; }
    toast("Event OPEN");
    await loadEvents(); await loadAdminEvents();
  });

  list.querySelectorAll("button[data-close]").forEach(b=>b.onclick=async ()=>{
    const id=Number(b.dataset.close);
    const r=await supabase.from("events").update({ status:"closed" }).eq("id", id);
    if(r.error){ toast("Failed"); console.error(r.error); return; }
    toast("Event CLOSED");
    await loadEvents(); await loadAdminEvents();
  });

  list.querySelectorAll("button[data-del]").forEach(b=>b.onclick=async ()=>{
    const id=Number(b.dataset.del);
    if(!confirm("Delete event? This will also delete its options and bets (because of FK).")) return;
    const r=await supabase.from("events").delete().eq("id", id);
    if(r.error){ toast("Delete failed"); console.error(r.error); return; }
    toast("Deleted");
    await loadEvents(); await loadAdminEvents();
  });

  list.querySelectorAll("button[data-finish]").forEach(b=>b.onclick=async ()=>{
    const evId=Number(b.dataset.finish);
    const winSel = list.querySelector(`select[data-win="${evId}"]`);
    const winnerId = Number(winSel?.value || 0);
    if(!winnerId) return toast("Select a winner first");

    const u = await supabase.from("events").update({ status:"settled", winner_option_id:winnerId }).eq("id", evId);
    if(u.error){ toast("Finish failed"); console.error(u.error); return; }

    const betsR = await supabase.from("bets")
      .select("id,user_id,stake,coef,option_id,status")
      .eq("event_id", evId)
      .eq("status", "pending")
      .limit(5000);
    if(betsR.error){ toast("Cannot load bets"); console.error(betsR.error); return; }
    const bets = betsR.data || [];

    const winners = bets.filter(x=>Number(x.option_id)===winnerId);
    const losers  = bets.filter(x=>Number(x.option_id)!==winnerId);

    if(winners.length){
      for(const w of winners){
        const payout = Number(to2(Number(w.stake)*Number(w.coef)));
        const ub = await supabase.from("bets").update({ status:"won", payout }).eq("id", w.id);
        if(ub.error){ console.error(ub.error); }
        const pr = await supabase.from("profiles").select("pts").eq("id", w.user_id).maybeSingle();
        if(!pr.error && pr.data){
          const newPts = clamp2(Number(pr.data.pts||0) + payout);
          const up = await supabase.from("profiles").update({ pts:newPts }).eq("id", w.user_id);
          if(up.error) console.error(up.error);
        }
      }
    }
    if(losers.length){
      for(const l of losers){
        const ub = await supabase.from("bets").update({ status:"lost", payout:0 }).eq("id", l.id);
        if(ub.error){ console.error(ub.error); }
      }
    }

    toast(`Finished. Paid ${winners.length} winners.`);
    await loadEvents();
    await loadAdminEvents();
    await ensureProfile();
    await loadMyBets();
    updateMeUI();
  });
}

// =======================
// BLACKJACK (Shuffle-style UI)
// - Deck top-right + bump
// - Deal animation + wind trail
// - Flip animation for hole card
// - Sounds (WebAudio)
// - Split / Double / Hit / Stand
// - Side bets: Perfect Pair 25x / Colored Pair 12x / Mixed Pair 6x, Bust Out tiered by dealer bust card count (3-4:2x, 5:4x, 6:15x, 7:50x, 8+:250x)
// - Win/Lose popup like mines (shows won or lost amount)
// - Outline winner green, loser red
// =======================

$("bjGem") && ($("bjGem").innerHTML = gemBlue());

function bjSfx(type="tap"){
  // Uses your existing WebAudio context (same as sfx)
  try{
    const ctx = window.__sfxCtx || (window.__sfxCtx = new (window.AudioContext||window.webkitAudioContext)());
    const now = ctx.currentTime;
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.connect(g); g.connect(ctx.destination);

    if(type==="deal"){
      o.type="triangle";
      o.frequency.setValueAtTime(520, now);
      o.frequency.exponentialRampToValueAtTime(240, now+0.06);
      g.gain.setValueAtTime(0.06, now);
      g.gain.exponentialRampToValueAtTime(0.001, now+0.08);
      o.start(now); o.stop(now+0.09);
      return;
    }
    if(type==="flip"){
      o.type="square";
      o.frequency.setValueAtTime(880, now);
      o.frequency.exponentialRampToValueAtTime(420, now+0.08);
      g.gain.setValueAtTime(0.05, now);
      g.gain.exponentialRampToValueAtTime(0.001, now+0.11);
      o.start(now); o.stop(now+0.12);
      return;
    }
    if(type==="win"){
      // small arpeggio
      const notes=[740, 880, 1046];
      notes.forEach((f,i)=>{
        const oo=ctx.createOscillator();
        const gg=ctx.createGain();
        oo.type="triangle";
        oo.frequency.value=f;
        gg.gain.setValueAtTime(0.0001, now+i*0.06);
        gg.gain.exponentialRampToValueAtTime(0.06, now+i*0.06+0.01);
        gg.gain.exponentialRampToValueAtTime(0.001, now+i*0.06+0.09);
        oo.connect(gg); gg.connect(ctx.destination);
        oo.start(now+i*0.06);
        oo.stop(now+i*0.06+0.10);
      });
      return;
    }
    if(type==="lose"){
      o.type="sawtooth";
      o.frequency.setValueAtTime(220, now);
      o.frequency.exponentialRampToValueAtTime(90, now+0.18);
      g.gain.setValueAtTime(0.08, now);
      g.gain.exponentialRampToValueAtTime(0.001, now+0.22);
      o.start(now); o.stop(now+0.23);
      return;
    }

    // tap
    o.type="sine";
    o.frequency.value=520;
    g.gain.value=0.03;
    o.start(); o.stop(now+0.05);
  }catch(_){}
}

const bj = {
  shoe: [],
  shoeDecks: 6,
  active: false,
  settled: false,
  stake: 0,
  sidePairs: 0,
  sideBust: 0,

  dealer: [],
  hands: [ [] ],        // player hands (hand0 + maybe hand1)
  handBets: [0],        // bet per hand (split duplicates)
  activeHand: 0,

  holeCardHidden: true,
  canDouble: false,
  canSplit: false,
};

function persistBlackjackState(){
  try{
    if(!(bj.active && !bj.settled)){
      sessionStorage.removeItem("handzes_bj_state_v1");
      return;
    }
    const payload = {
      active: !!bj.active,
      settled: !!bj.settled,
      stake: Number(bj.stake||0),
      sidePairs: Number(bj.sidePairs||0),
      sideBust: Number(bj.sideBust||0),
      dealer: Array.isArray(bj.dealer) ? bj.dealer : [],
      hands: Array.isArray(bj.hands) ? bj.hands : [[]],
      handBets: Array.isArray(bj.handBets) ? bj.handBets : [0],
      activeHand: Number(bj.activeHand||0),
      holeCardHidden: !!bj.holeCardHidden,
      canDouble: !!bj.canDouble,
      canSplit: !!bj.canSplit,
      shoe: Array.isArray(bj.shoe) ? bj.shoe : [],
      shoeDecks: Number(bj.shoeDecks||6),
    };
    sessionStorage.setItem("handzes_bj_state_v1", JSON.stringify(payload));
  }catch(_){ }
}

function clearBlackjackState(){
  try{ sessionStorage.removeItem("handzes_bj_state_v1"); }catch(_){ }
}

function restoreBlackjackState(){
  try{
    const raw = sessionStorage.getItem("handzes_bj_state_v1");
    if(!raw) return false;
    const saved = JSON.parse(raw);
    if(!saved || !saved.active || saved.settled){
      clearBlackjackState();
      return false;
    }

    bj.active = true;
    bj.settled = false;
    bj.stake = Number(saved.stake||0);
    bj.sidePairs = Number(saved.sidePairs||0);
    bj.sideBust = Number(saved.sideBust||0);
    bj.dealer = Array.isArray(saved.dealer) ? saved.dealer : [];
    bj.hands = Array.isArray(saved.hands) && saved.hands.length ? saved.hands : [[]];
    bj.handBets = Array.isArray(saved.handBets) && saved.handBets.length ? saved.handBets : [bj.stake||0];
    bj.activeHand = Math.max(0, Math.min(Number(saved.activeHand||0), bj.hands.length-1));
    bj.holeCardHidden = !!saved.holeCardHidden;
    bj.canDouble = !!saved.canDouble;
    bj.canSplit = !!saved.canSplit;
    bj.shoeDecks = Number(saved.shoeDecks||6) || 6;
    bj.shoe = Array.isArray(saved.shoe) ? saved.shoe : [];
    if(!bj.shoe.length) bjBuildShoe();

    bjRender();
    bjSetButtons();
    bjSetBetBtn(false);
    return true;
  }catch(_){
    clearBlackjackState();
    return false;
  }
}

function bjSuitChar(s){
  return s==="S"?"♠":(s==="H"?"♥":(s==="D"?"♦":"♣"));
}
function bjIsRed(s){ return (s==="H"||s==="D"); }

function bjBuildShoe(){
  const suits=["S","H","D","C"];
  const ranks=["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
  const shoe=[];
  for(let d=0; d<bj.shoeDecks; d++){
    for(const s of suits){
      for(const r of ranks){
        shoe.push({ r, s });
      }
    }
  }
  // Fisher-Yates
  for(let i=shoe.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [shoe[i], shoe[j]] = [shoe[j], shoe[i]];
  }
  bj.shoe = shoe;
  bjUpdateShoeUI();
}
function bjEnsureShoe(){
  if(!bj.shoe.length || bj.shoe.length < 52){
    bjBuildShoe();
  }
}
function bjDraw(){
  bjEnsureShoe();
  return bj.shoe.pop();
}

function bjCardValue(r){
  if(r==="A") return 11;
  if(r==="K"||r==="Q"||r==="J") return 10;
  return Number(r);
}
function bjHandTotals(cards){
  let sum=0, aces=0;
  for(const c of cards){
    const v=bjCardValue(c.r);
    sum += v;
    if(c.r==="A") aces++;
  }
  // adjust aces 11->1
  while(sum>21 && aces>0){
    sum -= 10; aces--;
  }
  const soft = cards.some(c=>c.r==="A") && sum<=21; // rough
  return { sum, soft };
}
function bjIsBlackjack(cards){
  return cards.length===2 && bjHandTotals(cards).sum===21;
}

function bjUpdateShoeUI(){
  if($("bjShoe")) $("bjShoe").textContent = `${bj.shoe.length}`;
}

function bjSetBetBtn(canBet=true){
  const btns=["bjBetBtn","bjBetBtnM"].map($).filter(Boolean);
  btns.forEach(b=>{
    if(canBet){
      b.disabled = false;
      b.style.opacity = "1";
      b.style.cursor = "pointer";
      b.textContent = "Bet";
    }else{
      b.disabled = true;
      b.style.opacity = "0.55";
      b.style.cursor = "not-allowed";
      b.textContent = "Bet placed ✓";
    }
  });
}

function bjSetButtons(){
  const inPlay = bj.active && !bj.settled;
  const h = bj.hands[bj.activeHand] || [];
  const totals = bjHandTotals(h).sum;

  const canHit = inPlay && totals < 21;
  const canStand = inPlay;
  const canDouble = inPlay && bj.canDouble && h.length===2;
  const canSplit = inPlay && bj.canSplit && h.length===2;

  const hitBtns=["bjHitBtn","bjHitBtnM"].map($).filter(Boolean);
  const standBtns=["bjStandBtn","bjStandBtnM"].map($).filter(Boolean);
  const dblBtns=["bjDoubleBtn","bjDoubleBtnM"].map($).filter(Boolean);
  const splitBtns=["bjSplitBtn","bjSplitBtnM"].map($).filter(Boolean);

  hitBtns.forEach(btn=>btn.disabled = !canHit);
  standBtns.forEach(btn=>btn.disabled = !canStand);
  dblBtns.forEach(btn=>btn.disabled = !canDouble);
  splitBtns.forEach(btn=>btn.disabled = !canSplit);

  // glow states for double / split
  [...dblBtns].forEach(d=>d.classList.toggle("bjPulseDouble", canDouble));
  [...splitBtns].forEach(s=>s.classList.toggle("bjPulseSplit", canSplit));

  // update active hand highlight in UI rows
  const rows = document.querySelectorAll("#bjPlayerCards .bjHandRow");
  rows.forEach((row,i)=> row.classList.toggle("active", i===bj.activeHand));

  // refresh per-hand meta totals on button refresh
  rows.forEach((row,i)=>{
    const meta=row.querySelector(".bjHandMeta");
    if(!meta) return;
    const hand=bj.hands[i]||[];
    const bet=to2(bj.handBets[i]||bj.stake||0);
    const total = hand.length ? bjHandTotals(hand).sum : "—";
    meta.textContent = `Hand ${i+1} · Bet ${bet} · Total ${total}`;
  });

  $("bjHandNo").textContent = String(bj.activeHand + 1);
}

function bjCardEl(card, faceDown=false){
  const wrap=document.createElement("div");
  wrap.className="bjCard" + (faceDown ? "" : " flipped");
  wrap.innerHTML = `
    <div class="bjTrail"></div>
    <div class="bjCardInner">
      <div class="bjFace">
        <div class="bjRank ${bjIsRed(card.s)?"bjRed":"bjBlack"}">${card.r}</div>
        <div class="bjSuit ${bjIsRed(card.s)?"bjRed":"bjBlack"}">${bjSuitChar(card.s)}</div>
        <div class="bjPip ${bjIsRed(card.s)?"bjRed":"bjBlack"}">${bjSuitChar(card.s)}</div>
      </div>
      <div class="bjBack"></div>
    </div>
  `;
  return wrap;
}

function bjGetHandRow(idx, create=false){
  const pBox=$("bjPlayerCards");
  if(!pBox) return null;
  const rows = Array.from(pBox.querySelectorAll(".bjHandRow"));
  if(rows[idx]) return rows[idx];
  if(!create) return null;
  const row=document.createElement("div");
  row.className="bjHandRow" + (idx===bj.activeHand ? " active" : "");
  row.dataset.hand=String(idx+1);
  const meta=document.createElement("div");
  meta.className="bjHandMeta";
  const cards=document.createElement("div");
  cards.className="bjHandCards";
  row.appendChild(meta);
  row.appendChild(cards);
  pBox.appendChild(row);
  return row;
}

function bjGetHandCards(idx){
  const row = bjGetHandRow(idx, true);
  if(!row) return null;
  let cards = row.querySelector(".bjHandCards");
  if(!cards){ cards=document.createElement("div"); cards.className="bjHandCards"; row.appendChild(cards); }
  return cards;
}

function bjDeckBump(){
  const d=$("bjDeck"); if(!d) return;
  d.classList.remove("bump"); void d.offsetWidth; d.classList.add("bump");
}

async function bjDealAnim(cardEl, toContainer){
  // deal from deck position to target container (wind trail)
  const deck=$("bjDeck");
  if(!deck || !toContainer) { toContainer.appendChild(cardEl); return; }

  // Snapshot existing card positions for smooth lane shift (FLIP)
  const prevRects = new Map();
  Array.from(toContainer.children).forEach(ch=>{
    prevRects.set(ch, ch.getBoundingClientRect());
  });

  bjDeckBump();
  bjSfx("deal");

  // start at deck rect
  const dr = deck.getBoundingClientRect();
  
  const alreadyStacked = toContainer.classList.contains("stacked");
  const childIndex = toContainer.children.length; // zero-based index for new card
  const willStack = alreadyStacked || childIndex >= 2;
  const stackOverlap = 36;
  const stackTopDefault = toContainer.id === "bjDealerCards" ? 64 : 0;
  const cardWidth = 104;

  // If stacking starts with this card (3rd card), pre-stack existing cards before anim so the third flies to stacked spot.
  if(willStack && !alreadyStacked){
    const count = childIndex;
    const stackWidth = cardWidth + Math.max(0, count-1)*stackOverlap;
    toContainer.classList.add("stacked");
    toContainer.style.position = "relative";
    toContainer.style.width = `${stackWidth}px`;
    toContainer.style.margin = "0 auto";
    toContainer.style.left = "";
    toContainer.style.transform = "";
    const topOffset = stackTopDefault;
    Array.from(toContainer.children).forEach((ch,i)=>{
      ch.style.position = "absolute";
      ch.style.left = `${i*stackOverlap}px`;
      ch.style.top = `${topOffset}px`;
      ch.style.zIndex = String(100 + i);
    });
  }

  const cr = toContainer.getBoundingClientRect();
  const stackTop = willStack ? stackTopDefault : 0;
  const baseOffset = 0;

  // Pre-calc target slot: stacked uses explicit coords; otherwise measure flex slot
  let tr;
  if(willStack){
    tr = {
      left: cr.left + baseOffset + childIndex * stackOverlap,
      top: cr.top + stackTop,
      width: cardEl.getBoundingClientRect().width,
      height: cardEl.getBoundingClientRect().height
    };
  }else{
    cardEl.style.visibility = "hidden";
    toContainer.appendChild(cardEl);
    tr = cardEl.getBoundingClientRect();
    toContainer.removeChild(cardEl);
    cardEl.style.visibility = "";
  }

  // create floating clone
  const float = cardEl.cloneNode(true);
  float.classList.add("dealing");
  float.style.position="fixed";
  float.style.left = "0px";
  float.style.top = "0px";
  float.style.zIndex="500"; // ensure incoming card flies above existing stack
  float.style.pointerEvents="none";
  document.body.appendChild(float);

  // after append, measure floating card size
  const fw = float.getBoundingClientRect().width;
  const fh = float.getBoundingClientRect().height;

  const startX = dr.left + dr.width/2 - fw/2;
  const startY = dr.top  + dr.height/2 - fh/2;
  float.style.left = startX + "px";
  float.style.top  = startY + "px";

  const xEnd = tr.left;
  const yEnd = tr.top;

  await float.animate([
    { transform:`translate(0px,0px) rotate(${Math.random()*6-3}deg) scale(.96)`, opacity:1 },
    { transform:`translate(${xEnd - startX}px, ${yEnd - startY}px) rotate(${Math.random()*6-3}deg) scale(1)` , opacity:1 }
  ], {
    duration: 380,
    easing: "cubic-bezier(.12,.8,.18,1)"
  }).finished.catch(()=>{});

  float.remove();
  toContainer.appendChild(cardEl);

  // If stacking, immediately place the real card at its stacked coordinates so it doesn't jump post-anim
  if(willStack){
    cardEl.style.position = "absolute";
    cardEl.style.left = `${baseOffset + childIndex * stackOverlap}px`;
    cardEl.style.top = `${stackTop}px`;
    cardEl.style.zIndex = String(200 + childIndex);
  }

  // Animate existing cards to their new slots (smooth spread)
  if(!willStack){
    bjAnimateLaneShift(toContainer, prevRects);
  }
}

function bjAnimateLaneShift(container, prevRects){
  const cards = Array.from(container.children);
  const isDealer = container.id === "bjDealerCards";
  cards.forEach(el=>{
    const prev = prevRects.get(el);
    if(!prev) return; // new card handled by deal anim
    const now = el.getBoundingClientRect();
    const dx = prev.left - now.left;
    const dy = prev.top - now.top;
    if(Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5) return;

    el.style.transition = "none";
    el.style.transform = `translate(${dx}px, ${dy}px)`;
    requestAnimationFrame(()=>{
      requestAnimationFrame(()=>{
        const duration = (isDealer && cards.length<=2) ? 220 : 260;
        const easing = (isDealer && cards.length<=2) ? "cubic-bezier(.22,.9,.3,1)" : "cubic-bezier(.16,.84,.22,1)";
        el.style.transition = `transform ${duration}ms ${easing}`;
        el.style.transform = "translate(0,0)";
        setTimeout(()=>{
          el.style.transition = "";
          el.style.transform = "";
        }, duration + 60);
      });
    });
  });
}

function bjRender(){
  const dBox=$("bjDealerCards");
  const pBox=$("bjPlayerCards");
  if(!dBox || !pBox) return;

  dBox.innerHTML="";
  pBox.innerHTML="";

  const isMobile = window.innerWidth <= 700;

  // Dealer cards (2+)
  const dealerShouldStack = bj.dealer.length > 2;
  const dealerOverlap = 36; // larger offset so more of each card stays visible
  const dealerTopOffset = 64; // drop stacked pile further to align with 2-card height
  const dealerBaseOffset = 0; // anchor at left of stack container; container itself is centered
  const dealerCardWidth = 104;
  const dealerStackWidth = dealerShouldStack ? (dealerCardWidth + Math.max(0, bj.dealer.length-1)*dealerOverlap) : 0;
  dBox.classList.toggle("stacked", dealerShouldStack);
  dBox.style.position = dealerShouldStack ? "relative" : "";
  dBox.style.width = dealerShouldStack ? `${dealerStackWidth}px` : "";
  dBox.style.margin = dealerShouldStack ? "0 auto" : "";
  dBox.style.minHeight = "";
  dBox.style.height = "";
  dBox.style.paddingTop = "";
  dBox.style.left = "";
  dBox.style.transform = "";
  bj.dealer.forEach((c, idx)=>{
    const faceDown = (idx===1 && bj.holeCardHidden);
    const el = bjCardEl(c, faceDown);
    if(dealerShouldStack){
      el.style.position = "absolute";
      el.style.left = `${dealerBaseOffset + idx*dealerOverlap}px`;
      el.style.top = `${dealerTopOffset}px`;
      el.style.zIndex = String(100 + idx);
      if(idx === bj.dealer.length - 1){
        el.classList.add("stackArrive");
        el.addEventListener("animationend", ()=> el.classList.remove("stackArrive"), { once:true });
      }
    }
    dBox.appendChild(el);
  });

  // Player: show all hands stacked with meta and cards
  bj.hands.forEach((hand, handIdx)=>{
    const row = bjGetHandRow(handIdx, true);
    if(!row) return;
    row.classList.toggle("active", handIdx===bj.activeHand);

    let meta=row.querySelector(".bjHandMeta");
    if(!meta){ meta=document.createElement("div"); meta.className="bjHandMeta"; row.prepend(meta); }
    const bet = to2(bj.handBets[handIdx]||bj.stake||0);
    const total = hand.length ? bjHandTotals(hand).sum : "—";
    meta.textContent = `Hand ${handIdx+1} · Bet ${bet} · Total ${total}`;

    const cards = bjGetHandCards(handIdx);
    if(cards){
      // rebuild cards fresh
      cards.innerHTML="";
      const shouldStack = hand.length > 2; // stack when 3+ cards to avoid overflow
      const overlap = 36; // larger offset so more of each card stays visible
      const baseOffset = 0;
      const cardWidth = 104;
      const stackWidth = shouldStack ? (cardWidth + Math.max(0, hand.length-1)*overlap) : 0;
      cards.classList.toggle("stacked", shouldStack);
      cards.style.position = shouldStack ? "relative" : "";
      cards.style.width = shouldStack ? `${stackWidth}px` : "";
      cards.style.margin = shouldStack ? "0 auto" : "";
      cards.style.left = "";
      cards.style.transform = "";
      hand.forEach((c, idx)=>{
        const el = bjCardEl(c, false);
        if(shouldStack){
          el.style.position = "absolute";
          el.style.left = `${baseOffset + idx*overlap}px`;
          el.style.top = "0";
          el.style.zIndex = String(100 + idx); // later cards sit on top
          if(idx === hand.length - 1){
            el.classList.add("stackArrive");
            el.addEventListener("animationend", ()=> el.classList.remove("stackArrive"), { once:true });
          }
        }else{
          el.style.position = "";
          el.style.left = "";
          el.style.top = "";
          el.style.zIndex = "";
        }
        cards.appendChild(el);
      });
    }
  });

  bjUpdateStackedLayouts();

  // set hand count for responsive scaling
  pBox.dataset.hands = String(bj.hands.length||1);

  bjUpdateScoresUI();
  bjSetButtons();
  bjUpdateShoeUI();
  persistBlackjackState();
}

function bjUpdateBalanceUI(){
  if(!$("bjBal")) return;
  $("bjBal").textContent = to2(meProfile?.pts||0);
}

function bjDealerScoreVisible(){
  if(!bj.dealer.length) return "—";
  if(bj.holeCardHidden && bj.dealer.length>=1){
    return String(bjHandTotals([bj.dealer[0]]).sum);
  }
  return String(bjHandTotals(bj.dealer).sum);
}

function bjUpdateScoresUI(){
  const dP=$("bjDealerPill"), pP=$("bjPlayerPill");
  const dS=$("bjDealerScore"), pS=$("bjPlayerScore");
  if(dP) dP.textContent = bjDealerScoreVisible();
  const pSum = bj.hands[bj.activeHand]?.length ? bjHandTotals(bj.hands[bj.activeHand]).sum : "—";
  if(pP) pP.textContent = String(pSum);
  if(dS) dS.textContent = bjDealerScoreVisible();
  if(pS) pS.textContent = String(pSum);
}

function bjUpdateStackedLayouts(){
  const isMobile = window.innerWidth <= 700;
  const dBox=$("bjDealerCards");
  if(dBox){
    const dealerStack = bj.dealer.length > 2;
    const overlap = 36; // match render overlap for more visibility
    const topOffset = 64; // mirror render() so stacked state sits at same height as 2-card layout
    const baseOffset = 0; // anchor at left; container is centered under pill
    const cardWidth = 104;
    const stackWidth = dealerStack ? (cardWidth + Math.max(0, bj.dealer.length-1)*overlap) : 0;
    dBox.classList.toggle("stacked", dealerStack);
    dBox.style.position = dealerStack ? "relative" : "";
    dBox.style.width = dealerStack ? `${stackWidth}px` : "";
    dBox.style.margin = dealerStack ? "0 auto" : "";
    dBox.style.minHeight = "";
    dBox.style.height = "";
    dBox.style.paddingTop = "";
    dBox.style.left = "";
    dBox.style.transform = "";
    if(dealerStack){
      Array.from(dBox.children).forEach((child, idx)=>{
        child.style.position = "absolute";
        child.style.left = `${baseOffset + idx*overlap}px`;
        child.style.top = `${topOffset}px`;
        child.style.zIndex = String(100 + idx);
      });
    }
  }
  bj.hands.forEach((hand, idx)=>{
    const cards=bjGetHandCards(idx);
    if(!cards) return;
    const shouldStack = hand.length > 2;
    const overlap = 36; // match render overlap for more visibility
    const baseOffset = 0;
    const cardWidth = 104;
    const stackWidth = shouldStack ? (cardWidth + Math.max(0, hand.length-1)*overlap) : 0;
    cards.classList.toggle("stacked", shouldStack);
    cards.style.position = shouldStack ? "relative" : "";
    cards.style.width = shouldStack ? `${stackWidth}px` : "";
    cards.style.margin = shouldStack ? "0 auto" : "";
    cards.style.left = "";
    cards.style.transform = "";
    // adjust existing stacked children if any
    if(shouldStack){
      Array.from(cards.children).forEach((child, idx)=>{
        child.style.left = `${baseOffset + idx*overlap}px`;
      });
    }
  });
}

function bjShowPop({ win=true, amount=0, text="", status=null }){
  const el=$("bjCenterPop"); if(!el) return;
  const isPush = status === "push";
  el.classList.remove("hide","lose","push");
  el.classList.toggle("lose", !isPush && !win);
  if(isPush) el.classList.add("push");

  $("bjPopLabel").textContent = isPush ? "PUSH" : (win ? "YOU WON" : "YOU LOST");
  $("bjPopAmt").textContent = to2(amount);
  $("bjPopSub").textContent = text || (isPush ? "stake returned" : (win ? "added to balance" : "deducted from balance"));
  const dot=$("bjPopDot");
  if(dot){
    if(isPush){
      dot.style.background = "rgba(245,158,11,.95)";
      dot.style.boxShadow = "0 0 10px rgba(245,158,11,.45)";
    }else{
      dot.style.background = win ? "rgba(34,197,94,.95)" : "rgba(239,68,68,.95)";
      dot.style.boxShadow = win ? "0 0 10px rgba(34,197,94,.45)" : "0 0 10px rgba(239,68,68,.45)";
    }
  }
  el.classList.add("show");
  clearTimeout(el._t);
  el._t=setTimeout(()=>{
    el.classList.add("hide");
    setTimeout(()=>el.classList.remove("show","hide"), 220);
  }, 2200);
}

async function bjCredit(amount){
  amount = Number(amount||0);
  if(!(amount>0)) return;
  const newPts = clamp2(Number(meProfile.pts) + amount);
  // Persist to DB, then update host balance
  const { error } = await supabase.from("profiles").update({ pts:newPts }).eq("id", session.user.id);
  if(error) throw error;
  setHostBalance(newPts);
}

function bjResetRound(){
  bj.active=false; bj.settled=false;
  bj.stake=0; bj.sidePairs=0; bj.sideBust=0;
  bj.dealer=[];
  bj.hands=[[]];
  bj.handBets=[0];
  bj.activeHand=0;
  bj.holeCardHidden=true;
  bj.canDouble=false;
  bj.canSplit=false;
  bjRender();
  bjSetButtons();
  // Hide BJ popup immediately
  const bjPop = $("bjCenterPop");
  if(bjPop){
    bjPop.classList.remove("show", "hide", "lose");
    clearTimeout(bjPop._t);
    bjPop.style.display = "none";
    setTimeout(()=>{ bjPop.style.display = ""; }, 250);
  }

  // Re-enable Bet button for next round
  bjSetBetBtn(true);

  // Re-enable Bet button for next round
  const betBtn = $("bjBetBtn");
  if(betBtn){
    betBtn.disabled = false;
    betBtn.style.opacity = "1";
    betBtn.style.cursor = "pointer";
    betBtn.textContent = "Bet";
  }
  clearBlackjackState();
}

function bjComputeCanSplit(){
  const h=bj.hands[bj.activeHand]||[];
  if(h.length!==2) return false;
  const r1=h[0].r, r2=h[1].r;
  const v1=bjCardValue(r1), v2=bjCardValue(r2);
  // Allow classic pairs OR any two ten-valued cards (K,Q,J,10)
  if(r1===r2) return true;
  return v1===10 && v2===10;
}

async function bjStart(){
  if(!meProfile) return toast("Profile not loaded");
  if(bj.active) return;

  const stake = Number($("bjStake").value);
  const sidePairs = Number($("bjSidePairs").value);
  const sideBust  = Number($("bjSideBust").value);

  if(!(stake>0) || stake<0.01) return toast("Min bet 0.01");
  if(sidePairs<0 || sideBust<0) return toast("Side bets invalid");

  const totalWager = clamp2(stake + sidePairs + sideBust);
  if(Number(meProfile.pts) < totalWager) return toast("Not enough points");

  // take wager now (counts to wager/level)
  try{
    await addWagerAndPayout(totalWager, 0);
  }catch(e){
    if(String(e).includes("balance")) return toast("Not enough points");
    toast("Blackjack start error (DB/RLS/SQL)");
    console.error(e);
    return;
  }

  bjResetRound();
  bj.active=true;
  bj.stake=stake;
  bj.sidePairs=sidePairs;
  bj.sideBust=sideBust;
  bj.handBets=[stake];
  // Visually grey out Bet button until round ends
  bjSetBetBtn(false);

  // Initial deal
  const dBox=$("bjDealerCards"), pBox=$("bjPlayerCards");
  if(!dBox || !pBox) return;

  // player 1
  const p1=bjDraw(); bj.hands[0].push(p1);
  const p1el=bjCardEl(p1,false); await bjDealAnim(p1el, bjGetHandCards(0)||pBox);

  // dealer up
  const d1=bjDraw(); bj.dealer.push(d1);
  const d1el=bjCardEl(d1,false); await bjDealAnim(d1el, dBox);

  // player 2
  const p2=bjDraw(); bj.hands[0].push(p2);
  const p2el=bjCardEl(p2,false); await bjDealAnim(p2el, bjGetHandCards(0)||pBox);

  // dealer hole (face down)
  const d2=bjDraw(); bj.dealer.push(d2);
  const d2el=bjCardEl(d2,true); // face down
  await bjDealAnim(d2el, dBox);

  // enable actions
  bj.canDouble=true;
  bj.canSplit=bjComputeCanSplit();
  bjRender(); // ensure rows exist & labeled before interactions
  bjSetButtons();
  bjUpdateScoresUI();

  // Side bet settle: Perfect Pair 25x / Colored Pair 12x / Mixed Pair 6x checks first 2 player cards
  let sideWin = 0;
  if(bj.sidePairs>0 && bj.hands[0].length>=2){
    const c1=bj.hands[0][0], c2=bj.hands[0][1];
    if(c1.r === c2.r){
      const bothRed = bjIsRed(c1.s) && bjIsRed(c2.s);
      const bothBlack = !bjIsRed(c1.s) && !bjIsRed(c2.s);
      if(c1.s === c2.s){
        sideWin += bj.sidePairs * 25; // Perfect Pair
      }else if(bothRed || bothBlack){
        sideWin += bj.sidePairs * 12; // Colored Pair
      }else{
        sideWin += bj.sidePairs * 6;  // Mixed Pair
      }
    }
  }

  // Immediate blackjack checks
  const pBJ = bjIsBlackjack(bj.hands[0]);
  const dBJ = bjIsBlackjack(bj.dealer);

  if(pBJ || dBJ){
    // reveal dealer card
    await bjRevealHole(true);

    let mainPayout=0;
    if(pBJ && !dBJ){
      // blackjack pays 3:2, payout includes stake return: stake*2.5 total back
      mainPayout = bj.stake * 2.5;
    }else if(pBJ && dBJ){
      // push -> return stake
      mainPayout = bj.stake * 1.0;
    }else{
      // dealer BJ -> 0
      mainPayout = 0;
    }

    // Bust Out side bet only if dealer busts -> not possible on BJ
    // credit winnings
    const totalWin = clamp2(mainPayout + sideWin);
    if(pBJ && dBJ){
      // Push case: show orange push banner
      await bjCredit(totalWin);
      bjSfx("tap");
      bjShowPop({ win:false, amount: totalWin, text:"stake returned", status:"push" });
    }else if(totalWin>0){
      await bjCredit(totalWin);
      bjSfx("win");
      bjShowPop({ win:true, amount: totalWin, text:"added to balance" });
    }else{
      bjSfx("lose");
      bjShowPop({ win:false, amount: clamp2(bj.stake + bj.sidePairs + bj.sideBust), text:"lost this round" });
    }

    bj.settled=true; bj.active=false;
    bjMarkOutcome();
    bjSetButtons();
    bjSetBetBtn(true);
    clearBlackjackState();
    return;
  }

  // if sideWin already, credit instantly (like side bet)
  if(sideWin>0){
    await bjCredit(sideWin);
    toast(`Side bet win +${to2(sideWin)}`);
    bjSfx("win");
  }

  toast("Blackjack started");
}

async function bjRevealHole(withFlipSound=false){
  bj.holeCardHidden=false;

  // flip animation for dealer second card
  const dBox=$("bjDealerCards");
  if(dBox && dBox.children && dBox.children[1]){
    const el=dBox.children[1];
    if(withFlipSound) bjSfx("flip");
    el.classList.add("flipped"); // show face
  }
  bjUpdateScoresUI();
}

async function bjHit(){
  if(!bj.active || bj.settled) return;
  bjSfx("tap");

  const pBox=bjGetHandCards(bj.activeHand) || $("bjPlayerCards");
  const card=bjDraw();
  bj.hands[bj.activeHand].push(card);

   // pre-stack before animation to avoid vertical jump on mobile
  const shouldStack = (window.innerWidth <= 700) && bj.hands[bj.activeHand].length > 3;
  if(pBox) pBox.classList.toggle("stacked", shouldStack);

  const el=bjCardEl(card,false);
  await bjDealAnim(el, pBox);

  const total=bjHandTotals(bj.hands[bj.activeHand]).sum;
  bj.canDouble=false;
  bj.canSplit=bjComputeCanSplit();
  bjUpdateScoresUI();
  bjRender();
  bjSetButtons();

  if(total>21){
    // bust => finish this hand
    await bjStand(true);
  }
}

async function bjDouble(){
  if(!bj.active || bj.settled) return;
  const h=bj.hands[bj.activeHand]||[];
  if(h.length!==2) return;

  const extra = bj.handBets[bj.activeHand] || bj.stake;
  if(Number(meProfile.pts) < extra) return toast("Not enough points to double");

  // take extra wager now (counts wager)
  try{
    await addWagerAndPayout(extra, 0);
  }catch(e){
    if(String(e).includes("balance")) return toast("Not enough points");
    toast("Double error");
    console.error(e);
    return;
  }

  bj.handBets[bj.activeHand] = clamp2((bj.handBets[bj.activeHand]||bj.stake) + extra);
  bj.canDouble=false;
  bj.canSplit=false;

  await bjHit();
  if(!bj.settled){
    await bjStand(true); // double locks the hand; advance to next/settle
  }
}

async function bjSplit(){
  if(!bj.active || bj.settled) return;
  const h=bj.hands[bj.activeHand]||[];
  if(h.length!==2) return;
  // allow exact pairs or any two ten-valued cards
  const v1=bjCardValue(h[0].r), v2=bjCardValue(h[1].r);
  const isPair = h[0].r===h[1].r;
  const isTenCombo = v1===10 && v2===10;
  if(!(isPair || isTenCombo)) return;

  const baseBet = bj.handBets[bj.activeHand] || bj.stake;
  const extra = baseBet;
  if(Number(meProfile.pts) < extra) return toast("Not enough points to split");

  // take extra wager now
  try{
    await addWagerAndPayout(extra, 0);
  }catch(e){
    if(String(e).includes("balance")) return toast("Not enough points");
    toast("Split error");
    console.error(e);
    return;
  }

  bjSfx("tap");

  // split current hand into two hands (insert new hand after active)
  const c1=h[0], c2=h[1];
  bj.hands[bj.activeHand] = [c1];
  bj.hands.splice(bj.activeHand+1, 0, [c2]);
  bj.handBets.splice(bj.activeHand+1, 0, baseBet);

  // render rows then deal one card to each split hand into its row
  bjRender();
  const row0 = bjGetHandCards(bj.activeHand) || $("bjPlayerCards");
  const a1=bjDraw(); bj.hands[bj.activeHand].push(a1);
  await bjDealAnim(bjCardEl(a1,false), row0);
  bjRender();

  const secondIdx = bj.activeHand+1;
  const row1 = bjGetHandCards(secondIdx) || $("bjPlayerCards");
  const a2=bjDraw(); bj.hands[secondIdx].push(a2);
  await bjDealAnim(bjCardEl(a2,false), row1);

  // stay on the original (left) hand
  bj.canSplit=false;
  bj.canDouble=true; // allow double on split hand if 2 cards
  bj.canSplit=bjComputeCanSplit();
  bjSetButtons();
  bjUpdateScoresUI();
  toast("Split");
  bjRender();
}

async function bjDealerPlay(){
  await bjRevealHole(true);

  // Dealer hits to 17+
  while(true){
    const t=bjHandTotals(bj.dealer).sum;
    if(t>=17) break;
    const dBox=$("bjDealerCards");
    const c=bjDraw(); bj.dealer.push(c);
    if(dBox){
      const willStack = (window.innerWidth <= 700) && bj.dealer.length > 3;
      dBox.classList.toggle("stacked", willStack);
    }
    const el=bjCardEl(c,false);
    await bjDealAnim(el, dBox);
    bjUpdateScoresUI();
    bjUpdateStackedLayouts();
  }
}

function bjOutcomeForHand(playerCards, dealerCards){
  const p = bjHandTotals(playerCards).sum;
  const d = bjHandTotals(dealerCards).sum;

  if(p>21) return "lose";
  if(d>21) return "win";
  if(p>d) return "win";
  if(p<d) return "lose";
  return "push";
}

async function bjStand(fromBust=false){
  if(!bj.active || bj.settled) return;

  // If split: advance through hands sequentially
  const p = bjHandTotals(bj.hands[bj.activeHand]).sum;
  const moreHands = bj.hands.length>1 && bj.activeHand < bj.hands.length-1;
  if(moreHands){
    bj.activeHand += 1;
    bj.canDouble=true;
    bj.canSplit=bjComputeCanSplit();
    bjSetButtons();
    bjRender();
    return;
  }

  // If split and active hand 2 -> proceed, or single hand -> proceed
  await bjDealerPlay();

  // side bet Bust Out: pays tiered if dealer busts (by dealer card count)
  let sideWin = 0;
  const dealerTotal=bjHandTotals(bj.dealer).sum;
  if(bj.sideBust>0 && dealerTotal>21){
    const dc = bj.dealer.length;
    let mult = 0;
    if(dc >= 8) mult = 250;
    else if(dc === 7) mult = 50;
    else if(dc === 6) mult = 15;
    else if(dc === 5) mult = 4;
    else if(dc === 3 || dc === 4) mult = 2;
    sideWin += bj.sideBust * mult;
  }

  // settle hands
  let totalCredit = 0;
  let totalLostShown = 0;

  for(let i=0;i<bj.hands.length;i++){
    const res=bjOutcomeForHand(bj.hands[i], bj.dealer);
    const bet = Number(bj.handBets[i]||bj.stake||0);

    if(res==="win"){
      // regular win pays 1:1 -> return stake + win = bet*2
      totalCredit += bet * 2;
    }else if(res==="push"){
      // return stake
      totalCredit += bet * 1;
    }else{
      // lose -> 0 returned
      totalLostShown += bet;
    }
  }

  totalCredit = clamp2(totalCredit + sideWin);

  if(totalCredit>0){
    try{
      await bjCredit(totalCredit);
    }catch(e){
      console.error(e);
      toast("Payout error");
    }
  }

  // show banner amount:
  // - credit > wager -> win
  // - credit == wager -> push
  // - else -> lose
  const totalHandsWager = (bj.handBets||[]).reduce((s,v)=>s + Number(v||0), 0);
  const totalWager = clamp2(totalHandsWager + bj.sidePairs + bj.sideBust);
  if(totalCredit > totalWager){
    bjSfx("win");
    bjShowPop({ win:true, amount: totalCredit, text:"added to balance" });
  }else if(totalCredit === totalWager){
    bjSfx("tap");
    bjShowPop({ win:false, amount: totalWager, text:"stake returned", status:"push" });
  }else{
    bjSfx("lose");
    bjShowPop({ win:false, amount: totalWager, text:"lost this round" });
  }

  bj.settled=true; bj.active=false;
  bjMarkOutcome();
  bjSetButtons();
  bjSetBetBtn(true);
  clearBlackjackState();
  toast("Round settled");
}

function bjMarkOutcome(){
  // Add outlines per hand: green win / red lose / yellow push
  const dBox=$("bjDealerCards");
  const pBox=$("bjPlayerCards");
  if(!dBox || !pBox) return;

  const dealerTotal=bjHandTotals(bj.dealer).sum;
  const dealerEls=[...dBox.children];
  const handRows=[...pBox.querySelectorAll(".bjHandRow")];

  // clear classes
  dealerEls.forEach(el=>el.classList.remove("bjWin","bjLose","bjPush"));
  handRows.forEach(el=>el.classList.remove("bjWin","bjLose","bjPush"));

  const outcomes=[];

  bj.hands.forEach((hand, idx)=>{
    const row = bjGetHandRow(idx, false) || handRows[idx];
    const res = bjOutcomeForHand(hand, bj.dealer);
    outcomes.push(res);
    if(!row) return;
    if(res==="win") row.classList.add("bjWin");
    else if(res==="lose") row.classList.add("bjLose");
    else row.classList.add("bjPush");
  });

  // Only tint dealer if all outcomes match; mixed results leave dealer neutral
  const uniq = Array.from(new Set(outcomes.filter(Boolean)));
  if(uniq.length===1){
    const res=uniq[0];
    if(res==="win") dealerEls.forEach(el=>el.classList.add("bjLose"));
    else if(res==="lose") dealerEls.forEach(el=>el.classList.add("bjWin"));
    else dealerEls.forEach(el=>el.classList.add("bjPush"));
  }else if(uniq.length && dealerTotal>21){
    // Dealer bust with mixed outcomes: still show dealer as losing
    dealerEls.forEach(el=>el.classList.add("bjLose"));
  }
}

$("bjBetBtn") && ($("bjBetBtn").onclick = bjStart);
$("bjHitBtn") && ($("bjHitBtn").onclick = bjHit);
$("bjStandBtn") && ($("bjStandBtn").onclick = ()=>bjStand(false));
$("bjDoubleBtn") && ($("bjDoubleBtn").onclick = bjDouble);
$("bjSplitBtn") && ($("bjSplitBtn").onclick = bjSplit);
$("bjBetBtnM") && ($("bjBetBtnM").onclick = bjStart);
$("bjHitBtnM") && ($("bjHitBtnM").onclick = bjHit);
$("bjStandBtnM") && ($("bjStandBtnM").onclick = ()=>bjStand(false));
$("bjDoubleBtnM") && ($("bjDoubleBtnM").onclick = bjDouble);
$("bjSplitBtnM") && ($("bjSplitBtnM").onclick = bjSplit);

// Keep mobile stake input in sync with desktop stake
const _stk=$("bjStake"), _stkM=$("bjStakeM");
if(_stk && _stkM){
  _stkM.value = _stk.value;
  _stkM.addEventListener("input", ()=>{ _stk.value = _stkM.value; });
  _stk.addEventListener("input", ()=>{ _stkM.value = _stk.value; });

  // Helper for min/max/half/double logic
  function getBalance() {
    const bal = $("bjBal");
    return bal ? Number(bal.textContent) : 0;
  }
  function setStake(val) {
    val = Math.max(0.01, Math.floor(val * 100) / 100);
    _stk.value = val.toFixed(2);
    _stkM.value = val.toFixed(2);
    _stk.dispatchEvent(new Event("input"));
    _stkM.dispatchEvent(new Event("input"));
  }

  // Desktop
  $("bjStakeMin") && ($("bjStakeMin").onclick = ()=> setStake(0.01));
  $("bjStakeMax") && ($("bjStakeMax").onclick = ()=> setStake(getBalance()));
  $("bjStakeHalf") && ($("bjStakeHalf").onclick = ()=> setStake(Number(_stk.value)/2));
  $("bjStakeDouble") && ($("bjStakeDouble").onclick = ()=> setStake(Number(_stk.value)*2));
  // Mobile
  $("bjStakeMinM") && ($("bjStakeMinM").onclick = ()=> setStake(0.01));
  $("bjStakeMaxM") && ($("bjStakeMaxM").onclick = ()=> setStake(getBalance()));
  $("bjStakeHalfM") && ($("bjStakeHalfM").onclick = ()=> setStake(Number(_stkM.value)/2));
  $("bjStakeDoubleM") && ($("bjStakeDoubleM").onclick = ()=> setStake(Number(_stkM.value)*2));
}

// Sync side bets between desktop and mobile inputs
const _pairs=$("bjSidePairs"), _pairsM=$("bjSidePairsM");
const _bust=$("bjSideBust"), _bustM=$("bjSideBustM");
if(_pairs && _pairsM){
  _pairsM.value = _pairs.value;
  _pairsM.addEventListener("input", ()=>{ _pairs.value = _pairsM.value; });
  _pairs.addEventListener("input", ()=>{ _pairsM.value = _pairs.value; });
}
if(_bust && _bustM){
  _bustM.value = _bust.value;
  _bustM.addEventListener("input", ()=>{ _bust.value = _bustM.value; });
  _bust.addEventListener("input", ()=>{ _bustM.value = _bust.value; });
}

// Keep BJ balance updated when switching view / refreshing
function bjOnViewEnter(){
  bjEnsureShoe();
  bjUpdateBalanceUI();
  bjUpdateShoeUI();
  if(restoreBlackjackState()) return;
  bjRender();
}

/* GAMES: Dice / Roulette / Mines */
["diceRollBtn","rouSpinBtn","minesStartBtn","minesCashBtn","openCaseBtn","mConfirm"].forEach(id=>{
  const el=$(id); if(el) el.addEventListener("click", ()=>sfx(520,0.05,"sine",0.03));
});

// Dice
$("diceRollBtn").onclick = async ()=>{
  if(!(await ensureActionReady())) return;
  if(!meProfile) return toast("Profile not loaded");
  const stake=Number($("diceStake").value);
  const pick=$("dicePick").value;
  const roll = Math.floor(Math.random()*100)+1;
  $("diceRollOut").textContent=String(roll);
  const win = (pick==="low") ? (roll<=49) : (roll>=50);
  const mult = 1.95;
  try{
    await addWagerAndPayout(stake, win ? stake*mult : 0);
    $("diceResOut").textContent = win ? `WIN +${to2(stake*mult - stake)}` : "LOSE";
    toast(win ? "Dice win" : "Dice lose");
  }catch(e){
    if(String(e).includes("balance")) toast("Not enough points");
    else toast("Dice error (DB/RLS/SQL)");
    console.error(e);
  }
};

// Roulette
$("rouSpinBtn").onclick = async ()=>{
  if(!(await ensureActionReady())) return;
  if(!meProfile) return toast("Profile not loaded");
  const stake=Number($("rouStake").value);
  const pick=$("rouPick").value;
  const n = Math.floor(Math.random()*37);
  let color = "green";
  if(n===0) color="green";
  else if(n>=1 && n<=18) color="red";
  else color="black";
  $("rouOut").textContent = `${n} (${color})`;
  const mult = (pick==="green") ? 14 : 1.95;
  const win = (pick===color);
  try{
    await addWagerAndPayout(stake, win ? stake*mult : 0);
    $("rouRes").textContent = win ? `WIN +${to2(stake*mult - stake)}` : "LOSE";
    toast(win ? "Roulette win" : "Roulette lose");
  }catch(e){
    if(String(e).includes("balance")) toast("Not enough points");
    else toast("Roulette error (DB/RLS/SQL)");
    console.error(e);
  }
};

/* =======================
   MINES (UPGRADED)
   ======================= */

const MINES_HOUSE_EDGE = 0.01; // 1% house edge (Stake-like feel). Change to 0.04 for 4%.

let mines = {
  active: false,
  bombs: 1,
  stake: 0,
  mult: 1.0,
  bombSet: new Set(),
  revealed: new Set(),   // safe picks only
  ended: false
};
let minesActionBusy = false;

function persistMinesState(){
  try{
    if(!(mines.active && !mines.ended)){
      sessionStorage.removeItem("handzes_mines_state_v1");
      return;
    }
    const payload = {
      active: !!mines.active,
      ended: !!mines.ended,
      bombs: Number(mines.bombs||1),
      stake: Number(mines.stake||0),
      mult: Number(mines.mult||1),
      bombSet: Array.from(mines.bombSet || []),
      revealed: Array.from(mines.revealed || []),
    };
    sessionStorage.setItem("handzes_mines_state_v1", JSON.stringify(payload));
  }catch(_){ }
}

function clearMinesState(){
  try{ sessionStorage.removeItem("handzes_mines_state_v1"); }catch(_){ }
}

function restoreMinesState(){
  try{
    const raw = sessionStorage.getItem("handzes_mines_state_v1");
    if(!raw) return false;
    const saved = JSON.parse(raw);
    if(!saved || !saved.active || saved.ended){
      clearMinesState();
      return false;
    }

    mines.active = true;
    mines.ended = false;
    mines.bombs = Math.max(1, Math.min(24, Number(saved.bombs||1)));
    mines.stake = Number(saved.stake||0);
    mines.mult = Number(saved.mult||1);
    mines.bombSet = new Set(Array.isArray(saved.bombSet) ? saved.bombSet : []);
    mines.revealed = new Set(Array.isArray(saved.revealed) ? saved.revealed : []);

    if($("minesBombs")) $("minesBombs").value = String(mines.bombs);
    if($("minesStake")) $("minesStake").value = to2(mines.stake||0);

    minesResetUI();
    const grid = $("minesGrid");
    if(grid){
      const tiles = [...grid.children];
      mines.revealed.forEach((idx)=>{
        const t = tiles[idx];
        if(!t) return;
        t.innerHTML = gemYellowMines();
        t.style.background = "rgba(34,197,94,.10)";
        t.classList.add("gemHit");
        t.dataset.locked = "1";
      });
    }

    $("minesStatus").textContent = "LIVE";
    setMinesUiState(true);
    renderMinesLadder();
    updateMinesTopPayout();
    persistMinesState();
    return true;
  }catch(_){
    clearMinesState();
    return false;
  }
}

function setMinesUiState(active){
  const startBtn = $("minesStartBtn");
  const cashBtn  = $("minesCashBtn");
  if(!startBtn || !cashBtn) return;

  if(active){
    startBtn.disabled = true;
    startBtn.textContent = "Bet placed ✓";
    startBtn.style.opacity = "0.55";
    startBtn.style.cursor = "not-allowed";
    cashBtn.disabled = false;
  } else {
    startBtn.disabled = false;
    startBtn.textContent = "Start";
    startBtn.style.opacity = "1";
    startBtn.style.cursor = "pointer";
    cashBtn.disabled = true;
  }
}

function minesResetUI(){
  const grid = $("minesGrid");
  if(!grid) return;
  grid.innerHTML = "";

  for(let i=0;i<25;i++){
    const b=document.createElement("button");
    b.className="btn";
    b.style.height="70px";
    b.style.borderRadius="16px";
    b.style.background="rgba(0,0,0,.35)";
    // anchor for explosion effects
    b.style.position = "relative";
    b.style.overflow = "visible";
    b.textContent=" ";
    b.onclick=()=>minesPick(i,b);
    grid.appendChild(b);
  }
}

function revealAllMines(){
  const grid = $("minesGrid");
  if(!grid) return;
  const tiles = [...grid.children];
  tiles.forEach((t, idx)=>{
    if(mines.bombSet.has(idx)){
      t.innerHTML = bombRed();
      t.classList.add("minesBombTile","bombHit","bombPulse");
      t.style.position = "relative";
    }
  });
}

function endMinesRound(statusLabel){
  mines.active = false;
  mines.ended = true;
  setMinesUiState(false);
  $("minesStatus").textContent = statusLabel;
  clearMinesState();
}

/* ---------- multipliers (probability-based) ----------
   Fair multiplier after k safe picks:
     1 / P(survive k picks)
   where P(survive k picks) = C(25-bombs, k) / C(25, k)

   Apply house edge:
     mult = fair * (1 - houseEdge)
----------------------------------------------------- */
function minesMultiplier(k, bombs){
  // Stake-like product formula for P(survive k picks):
  // P = Π_{i=0..k-1} (safe - i) / (total - i)
  const total = 25;
  const safe = total - bombs;

  if(k <= 0) return 1.00;
  if(k > safe) k = safe;

  let p = 1.0;
  for(let i=0; i<k; i++){
    p *= (safe - i) / (total - i);
  }

  const fair = 1 / Math.max(p, 1e-15);
  const edged = fair * (1 - MINES_HOUSE_EDGE);

  // round to 2 decimals for display
  return Math.max(1.00, Math.round((edged + Number.EPSILON) * 100) / 100);
}

function buildMinesLadder(bombs){
  const safe = 25 - bombs;
  const ladder = [];
  for(let k=1; k<=safe; k++){
    ladder.push({ k, x: minesMultiplier(k, bombs) });
  }
  return ladder;
}

function renderMinesLadder(){
  const bombs = mines.bombs;
  const safe = 25 - bombs;

  $("minesRightBombs").textContent = String(bombs);
  $("minesRightPicks").textContent = String(mines.revealed.size);

  const ladderEl = $("minesLadder");
  const floatEl  = $("minesXFloat");

  if(!ladderEl || !floatEl) return;

  const ladder = buildMinesLadder(bombs);
  ladderEl.innerHTML = "";

  const currentK = mines.revealed.size; // 0..safe
  const currentX = (currentK<=0) ? 1.00 : minesMultiplier(currentK, bombs);

  // floating X (animated bump)
  floatEl.classList.remove("bump");
  void floatEl.offsetWidth; // reflow for restart animation
  floatEl.classList.add("bump");
  floatEl.textContent = `x${to2(currentX)}`;

  ladder.forEach(step=>{
    const row = document.createElement("div");
    row.className = "minesStep" + (step.k === currentK ? " active" : "");
    row.innerHTML = `
      <div class="left">
        <div class="pickNo">${step.k}</div>
        <div class="mx">x${to2(step.x)}</div>
      </div>
      <div class="sub">${step.k===1 ? "1st pick" : `${step.k} picks`}</div>
    `;
    ladderEl.appendChild(row);
  });

  // keep active row in view
  const active = ladderEl.querySelector(".minesStep.active");
  if(active){
    active.scrollIntoView({ block:"nearest", behavior:"smooth" });
  }
}

function updateMinesTopPayout(){
  const stake = Number(mines.stake || $("minesStake").value || 0);
  const x = Number(mines.mult || 1);
  const payout = stake * x;
  $("minesPayoutTop").textContent = stake>0 ? to2(payout) : "—";
}

let __minesWinTimer = null;

function showMinesPop({ amount, mult=null, win=true }){
  const el = $("minesCenterPop");
  if(!el) return;

  el.classList.remove("hide");
  el.classList.toggle("lose", !win);

  $("minesPopLabel").textContent = win ? "CASHED OUT" : "BOMB";
  $("minesPopAmt").textContent = to2(amount);
  $("minesPopSub").textContent = win ? "added to balance" : "round lost";

  // ✅ multiplier smaller than payout
  const mxEl = $("minesPopMx");
  if(mxEl){
    if(mult == null){
      mxEl.style.display = "none";   // hide if you don't want it
    }else{
      mxEl.style.display = "";
      mxEl.textContent = `x${to2(mult)}`;
    }
  }

  el.classList.add("show");
  clearTimeout(el._t);
  el._t = setTimeout(()=>{
    el.classList.add("hide");
    setTimeout(()=>el.classList.remove("show","hide"), 220);
  }, 2200);
}

function hideMinesPop({ immediate=false } = {}){
  const el = $("minesCenterPop");
  if(!el) return;
  
  clearTimeout(el._t);
  
  if(!el.classList.contains("show")) return;
  
  if(immediate){
    el.classList.remove("hide");
    el.classList.remove("show");
    return;
  }
  
  el.classList.add("hide");
  setTimeout(()=>{
    el.classList.remove("hide");
    el.classList.remove("show");
  }, 220);
}

function spawnSparks(btn, n=10){
  btn.style.position = "relative";
  const total = n;
  for(let i=0;i<total;i++){
    const isDot = Math.random() < 0.35;
    const el = document.createElement("div");
    el.className = isDot ? "sparkDot" : "spark";
    
    const ang = Math.random() * Math.PI * 2;
    const dist = 26 + Math.random() * 34;
    const dx = Math.cos(ang) * dist;
    const dy = Math.sin(ang) * dist;
    
    el.style.setProperty("--dx", dx.toFixed(1) + "px");
    el.style.setProperty("--dy", dy.toFixed(1) + "px");
    el.style.animationDelay = (Math.random()*0.04).toFixed(3) + "s";
    
    btn.appendChild(el);
    setTimeout(()=>el.remove(), 800);
  }
}

// spawn a centered explosion (ring + sparks) on a tile
function spawnExplosionOn(btn){
  if(!btn) return;
  const boom = document.createElement("div");
  boom.className = "boom";

  // 8 sparks around
  for(let i=0;i<8;i++){
    const s = document.createElement("div");
    s.className = "spark";
    s.style.setProperty("--a", (i*45) + "deg");
    boom.appendChild(s);
  }

  btn.appendChild(boom);
  setTimeout(()=>boom.remove(), 520);
}

async function doMinesCashout({ auto=false } = {}){
  if(minesActionBusy) return;
  if(!mines.active || mines.ended) return;
  minesActionBusy = true;

  const safePicks = mines.revealed.size;
  if(safePicks === 0){
    minesActionBusy = false;
    return toast("Pick at least 1 tile");
  }

  const payout = mines.stake * mines.mult;

  try{
    const newPts = clamp2(Number(meProfile.pts) + payout);
    const { error } = await supabase
      .from("profiles")
      .update({ pts:newPts })
      .eq("id", session.user.id);
    if(error) throw error;

    setHostBalance(newPts);
    showMinesPop({ amount: payout, mult: mines.mult, win:true });

    // ✅ play money sound ONCE
    sfxCashout();

    // ✅ reveal bombs after cashout
    revealAllMines();

    toast(auto ? `Auto cashout +${to2(payout)}` : `Cashout +${to2(payout)}`);
    endMinesRound("CASHED");
  }catch(e){
    toast("Cashout failed (DB/RLS)");
    console.error(e);
  } finally {
    minesActionBusy = false;
  }
}

async function minesPick(i, btn){
  if(minesActionBusy) return;
  if(!session || !meProfile){
    await recoverAfterTabSwitch("mines-pick");
    if(!session || !meProfile) return toast("Session/Profile not ready");
  }
  if(!mines.active) return toast("Start mines first");
  if(mines.ended) return;
  if(btn.dataset.locked === "1") return;

  btn.dataset.locked = "1";

  try{
    // BOMB clicked
    if(mines.bombSet.has(i)){
      btn.style.background = "rgba(0,0,0,.35)";
      btn.style.borderColor = "rgba(255,255,255,.14)";
      btn.innerHTML = `<div class="bombIcon">💣</div>`;
      btn.classList.add("bombHit");
      spawnExplosionOn(btn);
      sfxBomb();
      revealAllMines();
      showMinesPop({ amount: 0, mult: null, win:false });
      endMinesRound("BOMB");
      toast("Boom 💣");
      return;
    }

    // SAFE clicked
    mines.revealed.add(i);
    btn.innerHTML = gemYellowMines();
    btn.style.background="rgba(34,197,94,.10)";
    btn.classList.add("gemHit");
    sfxGem();

    const safePicks = mines.revealed.size;
    mines.mult = minesMultiplier(safePicks, mines.bombs);
    $("minesStatus").textContent = "LIVE";
    renderMinesLadder();
    updateMinesTopPayout();
    persistMinesState();

    const totalSafe = 25 - mines.bombs;
    if(safePicks >= totalSafe){
      await doMinesCashout({ auto:true });
    }
  } catch (e) {
    btn.dataset.locked = "";
    console.error("minesPick error", e);
    toast("Mines recovered from error");
  }
}

function fillBombsSelect(){
  const sel = $("minesBombs");
  if(!sel) return;
  sel.innerHTML = "";
  for(let b=1; b<=24; b++){
    const o=document.createElement("option");
    o.value = String(b);
    o.textContent = `${b} bomb${b===1?"":"s"}`;
    sel.appendChild(o);
  }
  sel.value = "1";
}

$("minesStartBtn").onclick = async ()=> {
  if(!(await ensureActionReady())) return;
  hideMinesPop({ immediate:true });
  
  if(!meProfile) return toast("Profile not loaded");
  if(mines.active) return; // already playing

  const stake = Number($("minesStake").value);
  const bombs = Number($("minesBombs").value);

  if(!(stake>0)) return toast("Stake > 0");
  if(stake < 0.01) return toast("Min 0.01");
  if(!(bombs>=1 && bombs<=24)) return toast("Bombs must be 1-24");

  // remove stake now + count wager (your existing logic)
  try{
    await addWagerAndPayout(stake, 0);
  }catch(e){
    if(String(e).includes("balance")) return toast("Not enough points");
    toast("Mines start error (DB/RLS/SQL)");
    console.error(e);
    return;
  }

  // start round
  mines.active = true;
  mines.ended = false;
  mines.bombs = bombs;
  mines.stake = stake;
  mines.revealed = new Set();
  mines.mult = 1.0;

  mines.bombSet = new Set();
  while(mines.bombSet.size < bombs){
    mines.bombSet.add(Math.floor(Math.random()*25));
  }

  minesResetUI();
  $("minesStatus").textContent="LIVE";

  setMinesUiState(true);

  // ✅ init ladder + payout
  renderMinesLadder();
  updateMinesTopPayout();
  persistMinesState();

  toast("Mines started");
};

$("minesCashBtn").onclick = async ()=> {
  if(!(await ensureActionReady())) return;
  if(!mines.active) return toast("No active round");
  await doMinesCashout({ auto:false });
};

// init
fillBombsSelect();
setMinesUiState(false);
minesResetUI();
renderMinesLadder();
$("minesPayoutTop").textContent = "—";
restoreMinesState();

/* AUTH */
$("btnSignIn").onclick=async ()=>{
  if(!supabase) return;
  const email=$("inEmail").value.trim(); const password=$("inPass").value;
  const { error } = await supabase.auth.signInWithPassword({ email, password });
  if(error) toast(error.message);
};
$("btnForgot").onclick=async ()=>{
  if(!supabase) return;
  const email=$("inEmail").value.trim(); if(!email) return toast("Enter email");
  const { error } = await supabase.auth.resetPasswordForEmail(email);
  if(error) toast(error.message); else toast("Reset email sent");
};
$("btnSignUp").onclick=async ()=>{
  if(!supabase) return;
  const display_name=$("upName").value.trim();
  const email=$("upEmail").value.trim();
  const password=$("upPass").value;
  if(!display_name) return toast("Enter username");
  const { error } = await supabase.auth.signUp({ email, password, options:{ data:{ display_name } } });
  if(error) return toast(error.message);
  toast("Account created. If email confirm is ON, confirm then sign in.");
};

/* buttons */
$("refreshBtn").onclick=async ()=>{
  if(!supabase) return;
  await maybeRollMonth();
  await ensureProfileReady();
  await touchPresence();
  await normalizeMonthForMe();
  updateMeUI();
  await loadEvents();
  await loadMyBets();
  refreshCaseUI();
  if(isAdmin){ await loadAdminPlayers(); await loadAdminEvents(); }
  toast("Refreshed");
};
$("signOutBtn").onclick=async ()=>{ if(!supabase) return; await supabase.auth.signOut(); };

async function showApp(){
  stopAdminPlayersRealtime();
  if (adminPlayersPollTimer) { clearInterval(adminPlayersPollTimer); adminPlayersPollTimer = null; }
  adminBalanceSnapshotMap.clear();
  adminPlayersLoading = false;
  adminPlayersPending = false;
  $("authWrap").classList.remove("show");
  $("app").classList.add("show");
  isAdmin = isAdminEmail(session?.user?.email||"");
  startOnlineSignalChannel();
  startLivePresence();
  await maybeRollMonth();
  await ensureProfileReady();

  const adminDisplayName = getAdminDisplayNameByEmail(session?.user?.email||"");
  if(meProfile && adminDisplayName && meProfile.display_name !== adminDisplayName){
    await supabase.from("profiles").update({ display_name: adminDisplayName }).eq("id", session.user.id);
    meProfile.display_name = adminDisplayName;
  }

  await normalizeMonthForMe();
  await touchPresence();
  startPresenceHeartbeat();
  renderGames();
  updateMeUI();
  await loadEvents();
  await loadMyBets();
  refreshCaseUI();
  if(isAdmin){ await loadAdminPlayers(); await loadAdminEvents(); }
  let savedView = "home";
  try{ savedView = sessionStorage.getItem(LAST_VIEW_KEY) || "home"; }catch(_){ }
  const allowedViews = new Set(["home","games","dice","roulette","mines","blackjack","plinko","sports","leaderboard","bets","case","admin"]);
  let targetView = allowedViews.has(savedView) ? savedView : "home";
  if(targetView === "admin" && !isAdmin) targetView = "home";
  setView(targetView);
}
function showAuth(){
  stopPresenceHeartbeat();
  stopOnlineSignalChannel();
  stopLivePresence();
  if (adminPlayersPollTimer) { clearInterval(adminPlayersPollTimer); adminPlayersPollTimer = null; }
  stopAdminPlayersRealtime();
  adminBalanceSnapshotMap.clear();
  adminPlayersLoading = false;
  adminPlayersPending = false;
  $("app").classList.remove("show");
  $("authWrap").classList.add("show");
}

async function touchPresence(){
  if(!supabase || !session?.user?.id) return;
  const { error } = await supabase
    .from("profiles")
    .update({ last_seen: new Date().toISOString() })
    .eq("id", session.user.id);
  refreshAdminPlayerRowSelf();
  if(error){
    const msg = String(error.message||"");
    if(!/last_seen/i.test(msg)) console.error(error);
  }
}

function startPresenceHeartbeat(){
  stopPresenceHeartbeat();
  touchPresence();
  presenceTimer = setInterval(()=>{
    if(document.visibilityState === "visible"){
      touchPresence();
      sendOnlineSignal(true);
      try{ livePresenceChannel?.track({ user_id: String(session?.user?.id||""), email: String(session?.user?.email||"").toLowerCase(), online_at: new Date().toISOString() }); }catch(_){ }
    }
  }, 10000);
}

function stopPresenceHeartbeat(){
  if(presenceTimer){
    clearInterval(presenceTimer);
    presenceTimer = null;
  }
}

let tabRecoverInFlight = false;
let tabRecoverQueued = false;
let tabRecoverLastAt = 0;
const AUTO_RELOAD_KEY = "handzes_auto_reload_at";
const LAST_VIEW_KEY = "handzes_last_view";
let tabHiddenAt = 0;

function forceAppReload(reason="recover-failed"){
  try{
    try{ persistBlackjackState(); }catch(_){ }
    try{ persistMinesState(); }catch(_){ }
    const activeBtn = document.querySelector('.navBtn[data-view].active');
    const activeView = activeBtn?.dataset?.view || "home";
    sessionStorage.setItem(LAST_VIEW_KEY, activeView);
    const now = Date.now();
    const prev = Number(sessionStorage.getItem(AUTO_RELOAD_KEY) || 0);
    if(now - prev < 8000) return;
    sessionStorage.setItem(AUTO_RELOAD_KEY, String(now));
  }catch(_){ }
  console.warn("force reload:", reason);
  window.location.reload();
}

function withTimeout(promise, ms){
  return Promise.race([
    promise,
    new Promise((_, reject)=>setTimeout(()=>reject(new Error("timeout")), ms)),
  ]);
}

async function isRuntimeHealthy(){
  if(!supabase) return false;
  try{
    const s = await withTimeout(supabase.auth.getSession(), 3000);
    const liveSession = s?.data?.session || null;
    if(!liveSession) return false;
    if(!meProfile){
      await withTimeout(ensureProfileReady(), 3500);
    }
    return !!meProfile;
  }catch(_){
    return false;
  }
}

function getActiveView(){
  const btn = document.querySelector('.navBtn[data-view].active');
  return btn?.dataset?.view || "home";
}

async function ensureActionReady(showToast=true){
  if(!supabase) return false;

  if(!session || !meProfile || tabRecoverInFlight){
    try{
      await withTimeout(recoverAfterTabSwitch("pre-action"), 6000);
    }catch(_){ }
  }

  if(!session){
    if(showToast) toast("Session expired. Sign in again.");
    forceAppReload("no-session-on-action");
    showAuth();
    return false;
  }

  if(!meProfile){
    await ensureProfileReady();
  }
  if(!meProfile){
    if(showToast) toast("Profile not ready. Try again.");
    forceAppReload("no-profile-on-action");
    return false;
  }

  try{ sendOnlineSignal(true); }catch(_){ }
  try{ touchPresence(); }catch(_){ }
  return true;
}

async function recoverAfterTabSwitch(reason="focus"){
  if(!supabase) return;
  const now = Date.now();
  if(now - tabRecoverLastAt < 800) return;
  if(tabRecoverInFlight){
    tabRecoverQueued = true;
    return;
  }

  tabRecoverInFlight = true;
  tabRecoverLastAt = now;
  try{
    const viewBefore = getActiveView();
    let liveSession = null;
    try{
      const refreshed = await supabase.auth.refreshSession();
      liveSession = refreshed?.data?.session || null;
    }catch(_){ }
    if(!liveSession){
      const { data } = await supabase.auth.getSession();
      liveSession = data?.session || null;
    }
    session = liveSession;

    if(!session){
      showAuth();
      return;
    }

    if(!$("app").classList.contains("show")){
      await showApp();
      return;
    }

    stopPresenceHeartbeat();
    stopOnlineSignalChannel();
    stopLivePresence();
    if(isAdmin) stopAdminPlayersRealtime();

    startOnlineSignalChannel();
    startLivePresence();
    if(isAdmin && viewBefore === "admin") startAdminPlayersRealtime();

    await ensureProfileReady();
    if(!meProfile) await ensureProfile();
    if(!meProfile) {
      console.warn("tab recover: profile still missing", reason);
      return;
    }

    await touchPresence();
    sendOnlineSignal(true);
    startPresenceHeartbeat();

    updateMeUI();
    await loadEvents();
    await loadMyBets();
    refreshCaseUI();

    if(viewBefore === "leaderboard") await refreshLeaderboard();
    if(viewBefore === "admin" && isAdmin){
      await loadUsersList();
      await loadAdminPlayers();
      await loadAdminEvents();
    }
    if(viewBefore === "blackjack"){
      try{ bjOnViewEnter(); }catch(_){ }
    }
    if(viewBefore === "plinko"){
      try{
        if(meProfile) setHostBalance(Number(meProfile.pts || 0));
        if(window.plinkoResize) requestAnimationFrame(()=>window.plinkoResize());
      }catch(_){ }
    }

    if(viewBefore !== "home") setView(viewBefore);
  } catch(err){
    console.error("tab recover failed", reason, err);
  } finally {
    tabRecoverInFlight = false;
    if(tabRecoverQueued){
      tabRecoverQueued = false;
      setTimeout(()=>recoverAfterTabSwitch("queued"), 0);
    }
  }
}

let globalClickRecoverBusy = false;
const ACTION_GUARD_SKIP_ATTR = "data-action-guard-skip-once";
const ACTION_GUARD_NO_PROFILE = new Set([
  "tabSignIn","tabSignUp","btnSignIn","btnSignUp","btnForgot",
  "signOutBtn","refreshBtn"
]);

function getGuardTarget(node){
  if(!node?.closest) return null;
  return node.closest("button, .tile, .oddBtn, [role='button'], .navBtn");
}

function shouldGuardActionTarget(el){
  if(!el || !supabase) return false;
  if(!$("app")?.classList.contains("show")) return false;
  if(el.tagName === "BUTTON" && el.disabled) return false;

  if(el.getAttribute(ACTION_GUARD_SKIP_ATTR) === "1"){
    el.removeAttribute(ACTION_GUARD_SKIP_ATTR);
    return false;
  }

  const id = el.id || "";
  if(ACTION_GUARD_NO_PROFILE.has(id)) return false;

  return tabRecoverInFlight || !session || !meProfile;
}

async function recoverAndReplayAction(el){
  if(globalClickRecoverBusy) return;
  globalClickRecoverBusy = true;
  try{
    await withTimeout(recoverAfterTabSwitch("global-click"), 6500);
    const ok = await ensureActionReady(false);
    if(!ok){
      forceAppReload("global-click-not-ready");
      return;
    }

    el.setAttribute(ACTION_GUARD_SKIP_ATTR, "1");
    setTimeout(()=>{
      try{
        if(el.tagName === "BUTTON"){
          el.click();
        }else{
          el.dispatchEvent(new MouseEvent("click", { bubbles:true, cancelable:true, view:window }));
        }
      }catch(_){ }
    }, 0);
  }catch(err){
    console.error("global click recover failed", err);
    forceAppReload("global-click-failed");
  } finally {
    globalClickRecoverBusy = false;
  }
}

document.addEventListener("click", (e)=>{
  const targetEl = getGuardTarget(e.target);
  if(!targetEl) return;
  if(!document.getElementById("app")?.contains(targetEl)) return;
  if(!shouldGuardActionTarget(targetEl)) return;

  e.preventDefault();
  e.stopImmediatePropagation();
  recoverAndReplayAction(targetEl);
}, true);

window.addEventListener("visibilitychange", ()=>{
  if(document.visibilityState === "hidden"){
    tabHiddenAt = Date.now();
    return;
  }

  if(document.visibilityState === "visible"){
    const hiddenFor = tabHiddenAt ? (Date.now() - tabHiddenAt) : 0;

    // User requested instant refresh on return.
    if(hiddenFor > 500){
      forceAppReload("instant-return");
      return;
    }

    touchPresence();
    sendOnlineSignal(true);
    recoverAfterTabSwitch("visibility");
  }
});

window.addEventListener("focus", ()=>{
  recoverAfterTabSwitch("focus");
});

window.addEventListener("pageshow", ()=>{
  recoverAfterTabSwitch("pageshow");
});

window.addEventListener("online", ()=>{
  recoverAfterTabSwitch("network-online");
});

window.addEventListener("beforeunload", ()=>{
  try{
    sendOnlineSignal(false);
    stopOnlineSignalChannel();
    stopLivePresence();
    if(supabase && session?.user?.id){
      supabase.from("profiles").update({ last_seen: new Date().toISOString() }).eq("id", session.user.id);
    }
  }catch(_){ }
});

if(supabase){
  const { data } = await supabase.auth.getSession();
  session=data.session;
  if(session) await showApp(); else showAuth();
  supabase.auth.onAuthStateChange(async (_ev, newSession)=>{
    session=newSession;
    if(session) await showApp(); else showAuth();
  });
} else {
  showAuth();
}
</script>
<script>
// Plinko SPA loader
if (window.location.hash === "#plinko" || window.location.hash.startsWith("#plinko")) {
  const embed = document.getElementById("plinko-embed");
  if (embed) {
    fetch("/site/games/plinko/index.html").then(r => r.text()).then(html => {
      // Extract only the .layout div from the HTML
      const div = document.createElement("div");
      div.innerHTML = html;
      const layout = div.querySelector(".layout");
      if (layout) embed.innerHTML = "";
      if (layout) embed.appendChild(layout);
      // Load the JS
      const script = document.createElement("script");
      script.src = "/site/games/plinko/main.js";
      document.body.appendChild(script);
    });
  }
}
</script>
</body>
</html>

